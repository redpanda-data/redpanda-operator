// Copyright 2025 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

package schema

import (
	"encoding/json"
	"fmt"
	"maps"
	"os"
	"reflect"
	"slices"
	"strings"

	"github.com/invopop/jsonschema"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"github.com/spf13/cobra"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/util/intstr"

	consolechart "github.com/redpanda-data/redpanda-operator/charts/console/v3/chart"
	"github.com/redpanda-data/redpanda-operator/charts/redpanda/v25"
	operator "github.com/redpanda-data/redpanda-operator/operator/chart"
	"github.com/redpanda-data/redpanda-operator/pkg/valuesutil"
)

var schemas = map[string]any{
	"console":  &consolechart.Values{},
	"redpanda": &redpanda.Values{},
	"operator": &operator.Values{},
}

func Cmd() *cobra.Command {
	return &cobra.Command{
		Use: "schema",
		Run: run,
	}
}

func Must[T any](value T, err error) T {
	if err != nil {
		panic(err)
	}
	return value
}

func run(cmd *cobra.Command, args []string) {
	r := &jsonschema.Reflector{
		//  These values are set to minimize the diff between the
		// handwritten jsonschema and the generated jsonschema.
		ExpandedStruct: true,
		DoNotReference: true,

		// Explicitly deny any keys that aren't accept by the chart. This
		// prevents indent issues, typos, and usage of values from an older
		// release.
		AllowAdditionalProperties: false,

		// jsonschema, by default, will rely on omitempty flags to determine if
		// a value is required or not. This has too much of an impact on how
		// the underlying JSON is shaped and marshalled/unmarshalled. Instead,
		// rely on explicitly set required tags.
		RequiredFromJSONSchemaTags: true,

		AdditionalFields: func(t reflect.Type) []reflect.StructField {
			// HACK: Helm's `global` field is injected into values and
			// therefore checked against the schema. As console's going through
			// a major upgrade and connectors integration is slated to be
			// dropped, it's difficult to properly get the "Global" field set on them.
			// Instead, we'll look for all Values and PartialValues types and
			// inject the Global field from redpanda.
			// This can be removed once all charts  and dependencies thereof
			// have been updated.
			if !strings.HasPrefix(t.PkgPath(), "github.com/redpanda-data/redpanda-operator") {
				return nil
			}

			if !(t.Name() == "Values" || t.Name() == "PartialValues") {
				return nil
			}

			global, ok := reflect.TypeFor[redpanda.Values]().FieldByName("Global")
			if !ok {
				panic("Couldn't find field Global on redpanda.Values")
			}

			return []reflect.StructField{global}
		},

		// Builtin Kubernetes types can generate a JSON schema but it's a built
		// difficult to do so as all the information is stored in kubebuilder
		// annotations. For now, we'll hard code any types that need to be
		// enhanced.
		Mapper: func(t reflect.Type) *jsonschema.Schema {
			switch reflect.New(t).Interface().(type) {
			case *intstr.IntOrString:
				return &jsonschema.Schema{
					OneOf: []*jsonschema.Schema{
						{Type: "string"},
						{Type: "number"},
					},
				}
			case *corev1.PodFSGroupChangePolicy:
				return &jsonschema.Schema{
					Type: "string",
					Enum: []any{
						corev1.FSGroupChangeOnRootMismatch,
						corev1.FSGroupChangeAlways,
					},
				}
			case corev1.PullPolicy:
				return &jsonschema.Schema{
					Type: "string",
					Enum: []any{
						corev1.PullAlways,
						corev1.PullIfNotPresent,
						corev1.PullNever,
					},
				}
			case monitoringv1.Duration:
				return &jsonschema.Schema{
					Type:    "string",
					Pattern: "^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
				}
			case *resource.Quantity:
				return &jsonschema.Schema{
					OneOf: []*jsonschema.Schema{
						{Type: "integer"},
						{Type: "string", Pattern: "^[0-9]+(\\.[0-9]){0,1}(m|k|M|G|T|P|Ki|Mi|Gi|Ti|Pi)?$"},
					},
				}
			default:
				return nil
			}
		},
	}

	val, exists := schemas[append(args, "")[0]]
	if !exists {
		acceptable := strings.Join(slices.Collect(maps.Keys(schemas)), "|")
		fmt.Printf("schema %q does not exist\nusage: %s <%s>\n", args[0], cmd.CalledAs(), acceptable)
		os.Exit(1)
	}

	schema := r.Reflect(val)
	makeArrayNullableRecursive(schema)

	// Leave a note to dissuade any would be manual editors.
	schema.Description = "DO NOT EDIT!. This file was generated by ./cmd/genschema/genschema.go"

	// Because of jsonschema's usage of an ordered map, the key ordering is a
	// bit strange. Round trip through an untyped map[string]any to have go
	// sort the keys alphabetically. (This helps reduce diff churn).
	untyped := Must(valuesutil.UnmarshalInto[any](schema))
	data := Must(json.MarshalIndent(untyped, "", "  "))

	fmt.Printf("%s\n", data)
}

func makeArrayNullableRecursive(schema *jsonschema.Schema) {
	for pair := schema.Properties.Oldest(); pair != nil; pair = pair.Next() {
		if pair.Value.Type == "array" {
			schema.Properties.Set(pair.Key, &jsonschema.Schema{
				OneOf: []*jsonschema.Schema{
					pair.Value,
					{Type: "null"},
				},
			})
		}
		makeArrayNullableRecursive(pair.Value)
	}
}
