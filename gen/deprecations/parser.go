// Copyright 2025 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

package deprecations

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"path/filepath"
	"sort"
	"strings"

	"github.com/redpanda-data/redpanda-operator/gen/internal"
)

type Parser struct {
	config          DeprecationConfig
	structs         map[string]*ast.StructType
	files           []*ast.File
	crdDeprecations map[string][]fieldRef
	allDeprecations map[string][]fieldRef
}

func NewParser(config DeprecationConfig) *Parser {
	return &Parser{
		config:          config,
		structs:         make(map[string]*ast.StructType),
		crdDeprecations: make(map[string][]fieldRef),
		allDeprecations: make(map[string][]fieldRef),
	}
}

func (p *Parser) Parse() error {
	fset := token.NewFileSet()
	matches, err := filepath.Glob(filepath.Join(p.config.Directory, "*.go"))
	if err != nil {
		return fmt.Errorf("failed to glob files: %w", err)
	}

	pkgName := ""

	for _, fname := range matches {
		base := filepath.Base(fname)

		// skip any files that are test files or generated by us
		if base == p.config.OutputFile || strings.HasSuffix(base, "_test.go") {
			continue
		}

		f, err := parser.ParseFile(fset, fname, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse file %s: %w", fname, err)
		}

		if pkgName == "" {
			pkgName = f.Name.Name
		}
		p.files = append(p.files, f)

		// gather any structs we find
		for _, decl := range f.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, spec := range gd.Specs {
				ts := spec.(*ast.TypeSpec)
				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}
				p.structs[ts.Name.Name] = st
			}
		}
	}

	return nil
}

func (p *Parser) Compile() ([]byte, error) {
	p.compileAllDeprecations()
	p.compileDeprecatedCRDs()

	var fileContents bytes.Buffer
	if err := testGenerator.Execute(&fileContents, map[string]any{
		"Pkg":         p.config.PackageName,
		"Objs":        p.buildCRDObjects(),
		"TODOComment": p.compileTODO(),
	}); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	formatted, err := format.Source(fileContents.Bytes())
	if err != nil {
		if contextualErrors := internal.ContextualizeFormatErrors(fileContents.Bytes(), err); contextualErrors != "" {
			return nil, errors.New(contextualErrors)
		}
	}

	return formatted, err
}

func (p *Parser) compileAllDeprecations() {
	for tn := range p.structs {
		refs := p.collectDeprecations(tn, []string{}, []string{})
		p.config.Debugf("[deprecations] type %s returned %d deprecated fields\n", tn, len(refs))
		if len(refs) > 0 {
			p.allDeprecations[tn] = refs
		}
	}
}

func (p *Parser) compileDeprecatedCRDs() {
	for typeName, st := range p.structs {
		if isCRDRoot(st) {
			specField := findFieldByGoName(st, "Spec")
			if specField == nil {
				continue
			}
			specTypeName := typeNameOf(specField.Type)
			if specTypeName == "" {
				continue
			}
			refs := p.collectDeprecations(specTypeName, []string{"Spec"}, []string{jsonNameForField(specField)})
			p.config.Debugf("[deprecations] CRD root %q returned %d deprecated fields\n", typeName, len(refs))
			if len(refs) > 0 {
				p.crdDeprecations[typeName] = refs
			}
		}
	}
}

// collectDeprecations recursively finds Deprecated-prefixed fields starting from a named type
func (p *Parser) collectDeprecations(typeName string, goPath []string, jsonPath []string) []fieldRef {
	st, ok := p.structs[typeName]
	if !ok {
		return nil
	}
	var out []fieldRef
	for _, f := range st.Fields.List {
		// skip anonymous fields
		if len(f.Names) == 0 {
			continue
		}

		name := f.Names[0].Name
		jname := jsonNameForField(f)
		if strings.HasPrefix(name, DeprecationPrefix) {
			fr := fieldRef{
				GoPath:   append(append([]string{}, goPath...), name),
				JsonPath: append(append([]string{}, jsonPath...), jname),
				TypeExpr: f.Type,
			}

			p.config.Debugf("[deprecations] found deprecated %q at path %v\n", name, fr.GoPath)

			out = append(out, fr)
			continue
		}

		refType := typeNameOf(f.Type)
		if strings.Contains(refType, ".") {
			parts := strings.Split(refType, ".")
			refType = parts[len(parts)-1]
		}

		if _, exists := p.structs[refType]; exists {
			out = append(out, p.collectDeprecations(refType, append(append([]string{}, goPath...), name), append(append([]string{}, jsonPath...), jname))...)
		}
	}
	return out
}

func (p *Parser) compileTODO() string {
	poorlyNamed := extractPoorlyNamedDeprecatedFields(p.files, p.structs)
	crdsWithPoorlyNamedFields := make(map[string][]string)

	for crdName := range p.crdDeprecations {
		crdSt := p.structs[crdName]
		if crdSt == nil {
			continue
		}
		specField := findFieldByGoName(crdSt, "Spec")
		if specField == nil {
			continue
		}
		specTypeName := typeNameOf(specField.Type)
		if specTypeName == "" {
			continue
		}
		var fieldPaths []string
		p.flattenPoorlyNamedFieldsToGoPaths(specTypeName, poorlyNamed, "", &fieldPaths)
		if len(fieldPaths) > 0 {
			crdsWithPoorlyNamedFields[crdName] = fieldPaths
		}
	}

	var todoCommentLines []string
	todoCommentLines = append(todoCommentLines, "// TODO: The following fields are documented as deprecated in the API comments")
	todoCommentLines = append(todoCommentLines, "// but their Go field names do not use the `Deprecated` prefix. Consider")
	todoCommentLines = append(todoCommentLines, "// renaming them (or adding wrapper fields with the Deprecated prefix) so the")
	todoCommentLines = append(todoCommentLines, "// reflective deprecation detector can find them uniformly. Examples found in")
	todoCommentLines = append(todoCommentLines, "// this package:")
	todoCommentLines = append(todoCommentLines, "//")

	var crdNames []string
	for crdName := range crdsWithPoorlyNamedFields {
		crdNames = append(crdNames, crdName)
	}
	sort.Strings(crdNames)

	for _, crdName := range crdNames {
		fieldPaths := crdsWithPoorlyNamedFields[crdName]
		todoCommentLines = append(todoCommentLines, fmt.Sprintf("// - %s:", crdName))
		for _, fieldPath := range fieldPaths {
			todoCommentLines = append(todoCommentLines, fmt.Sprintf("//   - %s", fieldPath))
		}
	}

	return strings.Join(todoCommentLines, "\n")
}

type node struct {
	name     string
	children map[string]*node
	warnings []string
	typeExpr ast.Expr
}

func (p *Parser) buildRoots() []*node {
	nodes := []*node{}
	for tn, refs := range p.crdDeprecations {
		warnings := make([]string, len(refs))
		for i, ref := range refs {
			warnings[i] = fmt.Sprintf("field '%s' is deprecated and set", strings.Join(ref.JsonPath, "."))
		}

		root := &node{name: tn, children: make(map[string]*node), warnings: warnings}
		for _, r := range refs {
			cur := root
			for i, seg := range r.GoPath {
				isLast := i == len(r.GoPath)-1
				if cur.children[seg] == nil {
					cur.children[seg] = &node{children: make(map[string]*node)}
				}
				cur = cur.children[seg]
				if isLast {
					cur.typeExpr = r.TypeExpr
				}
			}
		}
		nodes = append(nodes, root)
	}

	return nodes
}

func (p *Parser) buildCRDObjects() []objSpec {
	objs := []objSpec{}
	for _, root := range p.buildRoots() {
		objs = append(objs, objSpec{Name: root.name, Literal: p.renderCRDLiteral(root), Warnings: root.warnings})
	}

	sort.SliceStable(objs, func(i, j int) bool {
		return objs[i].Name < objs[j].Name
	})

	return objs
}

func (p *Parser) renderCRDLiteral(root *node) string {
	return fmt.Sprintf("&%s{\nSpec: %s,\n}", root.name, p.renderSpecLiteral(root))
}

func (p *Parser) renderSpecLiteral(rootNode *node) string {
	rootSt := p.structs[rootNode.name]
	specField := findFieldByGoName(rootSt, "Spec")
	specType := extractSpecType(specField)

	if specType != "" {
		if rootNode.children["Spec"] == nil {
			rootNode.children["Spec"] = &node{children: map[string]*node{}}
		}
		return p.renderLiteral(specType, rootNode.children["Spec"])
	}
	return "struct{}{}"
}

func (p *Parser) renderLiteral(typeName string, n *node) string {
	p.config.Debugf("[render] typeName=%s, children=%d\n", typeName, len(n.children))
	if n == nil {
		return fmt.Sprintf("%s{}", typeName)
	}

	st := p.structs[typeName]
	parts := p.renderFields(st, n)

	if len(parts) == 0 {
		return fmt.Sprintf("%s{}", typeName)
	}
	return fmt.Sprintf("%s{\n%s,\n}", typeName, strings.Join(parts, ",\n"))
}

func (p *Parser) renderFields(st *ast.StructType, n *node) []string {
	var parts []string

	// Sort field names for stable output
	fieldNames := make([]string, 0, len(n.children))
	for fname := range n.children {
		fieldNames = append(fieldNames, fname)
	}
	sort.Strings(fieldNames)

	for _, fname := range fieldNames {
		child := n.children[fname]
		nested := p.renderField(st, fname, child)
		parts = append(parts, fmt.Sprintf("%s: %s", fname, nested))
	}
	return parts
}

func (p *Parser) renderField(st *ast.StructType, fname string, child *node) string {
	p.config.Debugf("[render]   field=%s, children=%d\n", fname, len(child.children))

	fieldTypeName, isPtr := extractFieldType(st, fname)

	if child.typeExpr != nil && len(child.children) == 0 {
		return literalForTypeExpr(child.typeExpr)
	}

	if fieldTypeName == "" && len(child.children) > 0 {
		fieldTypeName = p.findTypeFromChildren(child)
	}

	if len(child.children) == 0 && fieldTypeName != "" {
		return p.renderFieldWithDeprecations(fieldTypeName, isPtr)
	}

	if len(child.children) > 0 {
		return p.renderNestedField(fieldTypeName, child, isPtr)
	}

	return literalForFieldType(fieldTypeName, isPtr)
}

func (p *Parser) findTypeFromChildren(child *node) string {
	keys := make([]string, 0, len(child.children))
	for k := range child.children {
		keys = append(keys, k)
	}
	return findStructByFieldNames(p.structs, keys)
}

func (p *Parser) renderFieldWithDeprecations(fieldTypeName string, isPtr bool) string {
	if deps, ok := p.allDeprecations[fieldTypeName]; ok && len(deps) > 0 {
		tmp := buildNodeFromFieldRefs(deps)
		nested := p.renderLiteral(fieldTypeName, tmp)
		if isPtr && !strings.HasPrefix(nested, "&") {
			nested = "&" + nested
		}
		return nested
	}
	return literalForFieldType(fieldTypeName, isPtr)
}

func (p *Parser) renderNestedField(fieldTypeName string, child *node, isPtr bool) string {
	if fieldTypeName == "" {
		return fmt.Sprintf("struct{ %s }{}", "")
	}
	nested := p.renderLiteral(fieldTypeName, child)
	if isPtr && !strings.HasPrefix(nested, "&") {
		nested = "&" + nested
	}
	return nested
}

func (p *Parser) flattenPoorlyNamedFieldsToGoPaths(typeName string, poorlyNamed map[string][]string, prefix string, paths *[]string) {
	st, ok := p.structs[typeName]
	if !ok {
		return
	}

	// If this type has deprecated (no prefix) fields, add them
	if fields, hasDeprecated := poorlyNamed[typeName]; hasDeprecated {
		for _, field := range fields {
			if prefix == "" {
				*paths = append(*paths, field)
			} else {
				*paths = append(*paths, prefix+"."+field)
			}
		}
	}

	// Recurse into nested struct fields
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		fieldName := f.Names[0].Name

		// Skip Deprecated-prefixed fields
		if strings.HasPrefix(fieldName, DeprecationPrefix) {
			continue
		}

		nestedTypeName := typeNameOf(f.Type)
		if nestedTypeName == "" {
			continue
		}

		// Handle selector types (pkg.Type -> just Type)
		if strings.Contains(nestedTypeName, ".") {
			parts := strings.Split(nestedTypeName, ".")
			nestedTypeName = parts[len(parts)-1]
		}

		if _, exists := p.structs[nestedTypeName]; exists {
			newPrefix := fieldName
			if prefix != "" {
				newPrefix = prefix + "." + fieldName
			}
			p.flattenPoorlyNamedFieldsToGoPaths(nestedTypeName, poorlyNamed, newPrefix, paths)
		}
	}
}
