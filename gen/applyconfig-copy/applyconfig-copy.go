// Copyright 2026 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

//nolint:gosec // this is a code generation tool
package applyconfigcopy

import (
	"fmt"
	"go/ast"
	"go/format"
	"os"
	"strconv"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
	"golang.org/x/tools/go/packages"
)

type fileImport struct {
	Alias string
	Path  string
}

type copyTemplateData struct {
	InPath        string
	OutPath       string
	TypeString    string
	Alias         string
	SelectorName  string
	PackagePrefix string
	IsStruct      bool
	ElemCopy      string
}

type fileTemplateData struct {
	Header       string
	Package      string
	Imports      []fileImport
	DeepCopyCode string
}

type testTemplateData struct {
	Header     string
	Package    string
	Import     fileImport
	StructName string
}

type deepCopyTemplateData struct {
	StructName    string
	PackagePrefix string
	FieldCopies   string
}

const (
	structTemplateText   = `{{.OutPath}} = {{.PackagePrefix}}{{.TypeString}}{}`
	basicTemplateText    = `{{.OutPath}} = {{.InPath}}`
	selectorTemplateText = `{{.OutPath}} = {{.Alias}}.{{.SelectorName}}`
	arrayTemplateText    = `
if {{.InPath}} != nil {
	{{.OutPath}} = make({{.TypeString}}, len({{.InPath}}))
	{{- if .IsStruct }}
		for i := range {{.InPath}} {
			{{.ElemCopy}}
		}
	{{- else }}
		copy({{.OutPath}}, {{.InPath}})
	{{- end }}
}`
	mapTemplateText = `
if {{.InPath}} != nil {
	{{.OutPath}} = make({{.TypeString}}, len({{.InPath}}))
	for k, v := range {{.InPath}} {
		{{- if .IsStruct }}{{.ElemCopy}}{{- else }}{{.OutPath}}[k] = v{{- end }}
	}
}`
	starTemplateText = `
if {{.InPath}} != nil {
	{{- if .IsStruct }}
		{{.OutPath}} = new({{.PackagePrefix}}{{.TypeString}})
		{{.ElemCopy}}
	{{- else }}
		{{.OutPath}} = new({{.TypeString}})
		 *{{.OutPath}} = *{{.InPath}}
	{{- end }}
}`
	defaultTemplateText = `{{.OutPath}} = {{.InPath}}`
	fileTemplateText    = `// Code generated by gen/copy. DO NOT EDIT.

package {{.Package}}

{{if .Imports}}
import (
{{- range .Imports}}
{{- if and (ne .Alias "") (ne .Alias "_")}}
	{{.Alias}} "{{.Path}}"
{{- else}}
	"{{.Path}}"
{{- end}}
{{- end}}
)
{{end}}

{{.DeepCopyCode}}
`
	testTemplateText = `// Code generated by gen/copy. DO NOT EDIT.
	
package {{.Package}}
import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"pgregory.net/rapid"
	{{ .Import.Alias }} "{{ .Import.Path }}"

	"github.com/redpanda-data/redpanda-operator/pkg/rapidutil"
)

func TestDeepCopy{{.StructName}}(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		original := rapid.MakeCustom[{{ .Import.Alias }}.{{.StructName}}](rapidutil.KubernetesTypes).Draw(t, "original")

		// Marshal the original
		originalBytes, err := json.Marshal(original)
		require.NoError(t, err)

		// Deep copy
		copy := DeepCopy{{.StructName}}(&original)
		require.NotNil(t, copy)

		// Marshal the copy
		copyBytes, err := json.Marshal(copy)
		require.NoError(t, err)

		// Compare JSON
		assert.JSONEq(t, string(originalBytes), string(copyBytes), "DeepCopy{{.StructName}} did not copy all fields correctly")
	})
}
`
	deepCopyTemplateText = `func DeepCopy{{.StructName}}(in *{{.PackagePrefix}}{{.StructName}}) *{{.PackagePrefix}}{{.StructName}} {
	if in == nil {
		return nil
	}
	out := &{{.PackagePrefix}}{{.StructName}}{}
{{.FieldCopies}}
	return out
}`
)

var (
	structTemplate   *template.Template
	basicTemplate    *template.Template
	selectorTemplate *template.Template
	arrayTemplate    *template.Template
	mapTemplate      *template.Template
	starTemplate     *template.Template
	defaultTemplate  *template.Template
	fileTemplate     *template.Template
	deepCopyTemplate *template.Template
	testTemplate     *template.Template
)

func init() {
	structTemplate = template.Must(template.New("struct").Parse(structTemplateText))
	basicTemplate = template.Must(template.New("basic").Parse(basicTemplateText))
	selectorTemplate = template.Must(template.New("selector").Parse(selectorTemplateText))
	arrayTemplate = template.Must(template.New("array").Parse(arrayTemplateText))
	mapTemplate = template.Must(template.New("map").Parse(mapTemplateText))
	starTemplate = template.Must(template.New("star").Parse(starTemplateText))
	defaultTemplate = template.Must(template.New("default").Parse(defaultTemplateText))
	fileTemplate = template.Must(template.New("file").Parse(fileTemplateText))
	deepCopyTemplate = template.Must(template.New("deepCopy").Parse(deepCopyTemplateText))
	testTemplate = template.Must(template.New("test").Parse(testTemplateText))
}

func Cmd() *cobra.Command {
	var outFlag string
	var headerFlag string
	var structFlag string
	var outPackage string
	var testFlag string

	cmd := &cobra.Command{
		Use:     "applyconfig-copy [pkg]",
		Args:    cobra.ExactArgs(1),
		Example: "applyconfig-copy [--header ./path/to/license] [--package redpanda] --struct Values ./charts/redpanda",
		Run: func(cmd *cobra.Command, args []string) {
			run(args, outFlag, outPackage, headerFlag, structFlag, testFlag)
		},
	}

	cmd.Flags().StringVar(&outFlag, "out", "-", "The file to output to or `-` for stdout")
	cmd.Flags().StringVar(&outPackage, "package", "", "The package name to use for the output file. Defaults to the input package.")
	cmd.Flags().StringVar(&headerFlag, "header", "", "A file that will be used as a header for the generated file")
	cmd.Flags().StringVar(&structFlag, "struct", "", "The struct name to generate a partial for")
	cmd.Flags().StringVar(&testFlag, "test", "", "The output location for a test of the DeepCopy function for the specified struct")

	return cmd
}

func run(args []string, outFlag, outPackage, headerFlag, structFlag, testFlag string) {
	if structFlag == "" {
		fmt.Fprintf(os.Stderr, "--struct is required\n")
		os.Exit(1)
	}

	pkgPath := args[0]

	// Load the package
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}
	pkgs, err := packages.Load(cfg, pkgPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading package: %v\n", err)
		os.Exit(1)
	}

	if len(pkgs) != 1 {
		fmt.Fprintf(os.Stderr, "Expected exactly one package, found %d\n", len(pkgs))
		os.Exit(1)
	}

	pkg := pkgs[0]
	if len(pkg.Errors) > 0 {
		for _, err := range pkg.Errors {
			fmt.Fprintf(os.Stderr, "Package error: %v\n", err)
		}
		os.Exit(1)
	}

	inputPkgPath := pkg.PkgPath

	structTypes, imports, err := collectStructTypesAndImports(pkgPath, make(map[string]struct{}))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error collecting struct types and imports: %v\n", err)
		os.Exit(1)
	}

	// Check if the specified struct exists
	if _, ok := structTypes[structFlag]; !ok {
		fmt.Fprintf(os.Stderr, "Struct %s not found in package %s\n", structFlag, pkgPath)
		os.Exit(1)
	}
	parts := strings.Split(pkg.PkgPath, "/")
	pkgName := strings.Join(parts[len(parts)-2:], "") + "ac"

	// Generate DeepCopy code for all structs
	code := generateDeepCopyAll(pkgName, outPackage, structFlag, structTypes[structFlag], structTypes, imports, inputPkgPath)

	// Generate test if requested
	if testFlag != "" {
		var buf strings.Builder
		err := testTemplate.Execute(&buf, testTemplateData{
			Package:    outPackage,
			Import:     fileImport{Alias: pkgName, Path: inputPkgPath},
			StructName: structFlag,
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error templating test file: %v\n", err)
			os.Exit(1)
		}

		// Format the code
		src := buf.String()
		formatted, err := format.Source([]byte(src))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error formatting test file: %v\n", err)
			os.Exit(1)
		}

		testCode := string(formatted)
		if headerFlag != "" {
			header, err := os.ReadFile(headerFlag)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error reading header file: %v\n", err)
				os.Exit(1)
			}
			testCode = string(header) + "\n" + testCode
		}

		err = os.WriteFile(testFlag, []byte(testCode), 0o644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing test file: %v\n", err)
			os.Exit(1)
		}
	}

	// Add header if provided
	if headerFlag != "" {
		header, err := os.ReadFile(headerFlag)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading header file: %v\n", err)
			os.Exit(1)
		}
		code = string(header) + "\n" + code
	}

	// Output
	if outFlag == "-" {
		fmt.Print(code)
	} else {
		err := os.WriteFile(outFlag, []byte(code), 0o644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
			os.Exit(1)
		}
	}
}

func collectStructTypesAndImports(basePackage string, seen map[string]struct{}) (map[string]*ast.StructType, map[string]string, error) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}, basePackage)
	if err != nil {
		return nil, nil, err
	}

	imports := make(map[string]string)
	structTypes := make(map[string]*ast.StructType)
	for _, pkg := range pkgs {
		if _, ok := seen[pkg.PkgPath]; ok {
			continue
		}
		pkgStructs := collectStructTypesForPackage(pkg, seen)
		for name, st := range pkgStructs {
			if _, exists := structTypes[name]; exists {
				return nil, nil, fmt.Errorf("struct type conflict: %s defined in multiple packages", name)
			}
			structTypes[name] = st
		}
		pkgImports, err := collectImportsForPackage(pkg, seen)
		if err != nil {
			return nil, nil, err
		}
		for alias, path := range pkgImports {
			if existingPath, exists := imports[alias]; exists && existingPath != path {
				return nil, nil, fmt.Errorf("import alias conflict: %s maps to both %s and %s", alias, existingPath, path)
			}
			imports[alias] = path
		}

		seen[pkg.PkgPath] = struct{}{}
	}

	for _, importName := range imports {
		importStructTypes, importImports, err := collectStructTypesAndImports(importName, seen)
		if err != nil {
			return nil, nil, err
		}
		for name, st := range importStructTypes {
			structTypes[name] = st
		}
		for impAlias, impPath := range importImports {
			if existingPath, exists := imports[impAlias]; exists && existingPath != impPath {
				return nil, nil, fmt.Errorf("import alias conflict: %s maps to both %s and %s", impAlias, existingPath, impPath)
			}
			imports[impAlias] = impPath
		}
	}

	return structTypes, imports, nil
}

func collectImportsForPackage(pkg *packages.Package, seen map[string]struct{}) (map[string]string, error) {
	if _, ok := seen[pkg.PkgPath]; ok {
		return nil, nil
	}

	imports := make(map[string]string) // alias -> path
	for _, file := range pkg.Syntax {
		for _, imp := range file.Imports {
			importPath := strings.Trim(imp.Path.Value, "\"")
			if !strings.Contains(importPath, "k8s.io/apimachinery/pkg/api") &&
				!strings.Contains(importPath, "k8s.io/apimachinery/pkg/util/intstr") &&
				!strings.Contains(importPath, "k8s.io/api/core/v1") &&
				!strings.Contains(importPath, "k8s.io/client-go/applyconfigurations") {
				// we only care about k8s apimachinery and client-go applyconfigurations imports
				continue
			}

			alias := ""
			if imp.Name != nil {
				alias = imp.Name.Name
				if strings.Contains(importPath, "applyconfiguration") {
					// add in ac for conflicts
					alias = alias + "ac"
				}
			} else {
				// Default alias is last element of import path
				parts := strings.Split(importPath, "/")
				alias = parts[len(parts)-1]
				last := alias[len(alias)-1]
				if _, err := strconv.ParseInt(string(last), 10, 64); err == nil {
					alias = strings.Join(parts[len(parts)-2:], "")
				}
			}
			i := 2
			for existingPath, exists := imports[alias]; exists && existingPath != importPath; i++ {
				parts := strings.Split(importPath, "/")
				if len(parts) < i {
					return nil, fmt.Errorf("import alias conflict: %s maps to both %s and %s", alias, existingPath, importPath)
				}
				alias = parts[len(parts)-i] + alias
				existingPath, exists = imports[alias]
			}
			imports[alias] = importPath
			imports[importPath] = alias
		}
	}

	return imports, nil
}

func collectStructTypesForPackage(pkg *packages.Package, seen map[string]struct{}) map[string]*ast.StructType {
	if _, ok := seen[pkg.PkgPath]; ok {
		return nil
	}

	structTypes := make(map[string]*ast.StructType)

	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if ts, ok := n.(*ast.TypeSpec); ok {
				if st, ok := ts.Type.(*ast.StructType); ok {
					structTypes[ts.Name.Name] = st
				}
			}
			return true
		})
	}
	return structTypes
}

func generateDeepCopyAll(pkgName, outPkg, name string, structType *ast.StructType, structTypes map[string]*ast.StructType, imports map[string]string, inputPkgPath string) string {
	if outPkg == "" {
		outPkg = pkgName
	}

	usedImports := make(map[string]string)

	pkgPrefix := ""
	if outPkg != pkgName {
		pkgPrefix = pkgName + "."
		usedImports[pkgName] = inputPkgPath
	}

	// Generate DeepCopy code and collect imports as we go
	deepCopyCode := generateDeepCopyForStructWithImports(name, structType, structTypes, pkgPrefix, usedImports, imports)

	importsList := []fileImport{}
	for alias, path := range usedImports {
		importsList = append(importsList, fileImport{Alias: alias, Path: path})
	}

	var buf strings.Builder
	err := fileTemplate.Execute(&buf, fileTemplateData{
		Package:      outPkg,
		Imports:      importsList,
		DeepCopyCode: deepCopyCode,
	})
	if err != nil {
		return "// template error: " + err.Error()
	}

	// Format the code
	src := buf.String()
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return src // return unformatted if error
	}
	return string(formatted)
}

// generateDeepCopyForStructWithImports is like generateDeepCopyForStruct but also collects imports as it generates code
func generateDeepCopyForStructWithImports(structName string, structType *ast.StructType, structTypes map[string]*ast.StructType, pkgPrefix string, usedImports map[string]string, imports map[string]string) string {
	var fieldCopies strings.Builder
	for _, field := range structType.Fields.List {
		if field.Names == nil {
			typeName := ""
			switch t := field.Type.(type) {
			case *ast.Ident:
				typeName = t.Name
			case *ast.SelectorExpr:
				typeName = t.Sel.Name
			}
			if typeName != "" {
				generateCopyWithImports(&fieldCopies, fmt.Sprintf("in.%s", typeName), fmt.Sprintf("out.%s", typeName), "", field.Type, structTypes, pkgPrefix, usedImports, imports, false)
			}
			continue
		}
		for _, name := range field.Names {
			fieldName := name.Name
			generateCopyWithImports(&fieldCopies, fmt.Sprintf("in.%s", fieldName), fmt.Sprintf("out.%s", fieldName), "", field.Type, structTypes, pkgPrefix, usedImports, imports, false)
		}
	}
	// Use deepCopyFuncTemplateText for the struct DeepCopy function
	var buf strings.Builder
	deepCopyTemplate.Execute(&buf, deepCopyTemplateData{
		StructName:    structName,
		PackagePrefix: pkgPrefix,
		FieldCopies:   fieldCopies.String(),
	})
	return buf.String()
}

// generateCopyWithImports is like generateCopy but also collects imports as it generates code
func generateCopyWithImports(buf *strings.Builder, inPath, outPath, knownPkg string, expr ast.Expr, structTypes map[string]*ast.StructType, pkgPrefix string, usedImports map[string]string, imports map[string]string, skipInitial bool) {
	switch t := expr.(type) {
	case *ast.Ident:
		if st, ok := structTypes[t.Name]; ok {
			var fieldCopies strings.Builder
			for _, field := range st.Fields.List {
				if field.Names == nil {
					typeName := ""
					switch t := field.Type.(type) {
					case *ast.Ident:
						typeName = t.Name
					case *ast.SelectorExpr:
						typeName = t.Sel.Name
					case *ast.StarExpr:
						switch xt := t.X.(type) {
						case *ast.Ident:
							typeName = xt.Name
						case *ast.SelectorExpr:
							typeName = xt.Sel.Name
						}
					}
					if typeName != "" {
						subIn := fmt.Sprintf("(%s).%s", inPath, typeName)
						subOut := fmt.Sprintf("(%s).%s", outPath, typeName)
						fieldCopies.WriteString("\n")
						generateCopyWithImports(&fieldCopies, subIn, subOut, knownPkg, field.Type, structTypes, pkgPrefix, usedImports, imports, false)
					}
					continue
				}
				for _, name := range field.Names {
					subIn := fmt.Sprintf("(%s).%s", inPath, name.Name)
					subOut := fmt.Sprintf("(%s).%s", outPath, name.Name)
					fieldCopies.WriteString("\n")
					generateCopyWithImports(&fieldCopies, subIn, subOut, knownPkg, field.Type, structTypes, pkgPrefix, usedImports, imports, false)
				}
			}
			if !skipInitial {
				structTemplate.Execute(buf, copyTemplateData{
					OutPath:       outPath,
					PackagePrefix: pkgPrefix,
					TypeString:    t.Name,
				})
			}
			buf.WriteString(fieldCopies.String())
		} else {
			name := t.Name
			if knownPkg != "" {
				name = knownPkg
			}
			if path, ok := imports[name]; ok && path != "" {
				usedImports[name] = path
			}
			basicTemplate.Execute(buf, copyTemplateData{
				OutPath: outPath,
				InPath:  inPath,
			})
		}
	case *ast.SelectorExpr:
		if !skipInitial {
			selectorTemplate.Execute(buf, copyTemplateData{
				OutPath:      outPath,
				Alias:        knownPkg,
				SelectorName: t.Sel.Name,
			})
		}
		generateCopyWithImports(buf, inPath, outPath, knownPkg, t.X, structTypes, pkgPrefix, usedImports, imports, false)
	case *ast.ArrayType:
		var elemCopy string
		if isStructType(t.Elt, structTypes) {
			var subBuf strings.Builder
			subBuf.WriteString(fmt.Sprintf("in, out := &%s[i], &%s[i]\n", inPath, outPath))
			generateCopyWithImports(&subBuf, "in", "out", knownPkg, t.Elt, structTypes, pkgPrefix, usedImports, imports, true)
			elemCopy = subBuf.String()
		}
		arrayTemplate.Execute(buf, copyTemplateData{
			InPath:     inPath,
			OutPath:    outPath,
			TypeString: typeString(t, pkgPrefix, usedImports, imports),
			IsStruct:   isStructType(t.Elt, structTypes),
			ElemCopy:   elemCopy,
		})
	case *ast.MapType:
		var elemCopy string
		if isStructType(t.Value, structTypes) {
			var subBuf strings.Builder
			subBuf.WriteString(fmt.Sprintf("in, out := &v, &%s[k]\n", outPath))
			generateCopyWithImports(&subBuf, "in", "out", knownPkg, t.Value, structTypes, pkgPrefix, usedImports, imports, true)
			elemCopy = subBuf.String()
		}
		mapTemplate.Execute(buf, copyTemplateData{
			InPath: inPath, OutPath: outPath,
			TypeString: typeString(t, pkgPrefix, usedImports, imports),
			IsStruct:   isStructType(t.Value, structTypes),
			ElemCopy:   elemCopy,
		})
	case *ast.StarExpr:
		var elemCopy string
		prefix := pkgPrefix
		knownPkg := ""
		typeString := typeString(t.X, "", usedImports, imports)
		if strings.Contains(typeString, ".") {
			prefix = ""
			parts := strings.Split(typeString, ".")
			knownPkg = parts[0]
		}

		if isStructType(t.X, structTypes) {
			var subBuf strings.Builder
			generateCopyWithImports(&subBuf, fmt.Sprintf("*%s", inPath), fmt.Sprintf("*%s", outPath), knownPkg, t.X, structTypes, pkgPrefix, usedImports, imports, true)
			elemCopy = subBuf.String()
		}

		isStruct := isStructType(t.X, structTypes)

		starTemplate.Execute(buf, copyTemplateData{
			InPath:        inPath,
			OutPath:       outPath,
			TypeString:    typeString,
			PackagePrefix: prefix,
			IsStruct:      isStruct,
			ElemCopy:      elemCopy,
		})
	default:
		if !skipInitial {
			defaultTemplate.Execute(buf, copyTemplateData{
				OutPath: outPath,
				InPath:  inPath,
			})
		}
	}
}

func isStructType(expr ast.Expr, structTypes map[string]*ast.StructType) bool {
	switch t := expr.(type) {
	case *ast.Ident:
		_, ok := structTypes[t.Name]
		return ok
	case *ast.StarExpr:
		return isStructType(t.X, structTypes)
	case *ast.SelectorExpr:
		// Try to resolve qualified name for imported struct
		if ident, ok := t.X.(*ast.Ident); ok {
			qualified := ident.Name + "." + t.Sel.Name
			_, ok := structTypes[qualified]
			return ok || strings.HasSuffix(t.Sel.Name, "ApplyConfiguration")
		}
		return false
	default:
		return false
	}
}

func typeString(expr ast.Expr, pkgPrefix string, usedImports map[string]string, imports map[string]string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64",
			"string", "bool",
			"byte", "rune":
			return t.Name
		default:
			return pkgPrefix + t.Name
		}
	case *ast.ArrayType:
		return "[]" + typeString(t.Elt, pkgPrefix, usedImports, imports)
	case *ast.MapType:
		return "map[" + typeString(t.Key, pkgPrefix, usedImports, imports) + "]" + typeString(t.Value, pkgPrefix, usedImports, imports)
	case *ast.StarExpr:
		return "*" + typeString(t.X, pkgPrefix, usedImports, imports)
	case *ast.SelectorExpr:
		alias := ""
		if ident, ok := t.X.(*ast.Ident); ok {
			name := ident.Name
			if strings.Contains(t.Sel.Name, "ApplyConfiguration") {
				name = name + "ac"
			}
			if path, ok := imports[name]; ok && path != "" {
				usedImports[name] = path
				alias = name
			} else {
				alias = name
			}
		}
		if alias != "" {
			return alias + "." + t.Sel.Name
		}
		return pkgPrefix + t.Sel.Name
	default:
		panic("unhandled type")
	}
}
