// Copyright 2026 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

//nolint:gosec // this is a code generation tool
package applyconfigcopy

import (
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"os"
	"strconv"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
	"golang.org/x/tools/go/packages"
)

var loadConfig = &packages.Config{
	Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
}

type fileImport struct {
	Alias string
	Path  string
}

type copyTemplateData struct {
	InPath        string
	OutPath       string
	TypeString    string
	Alias         string
	SelectorName  string
	PackagePrefix string
	IsStruct      bool
	ElemCopy      string
}

type fileTemplateData struct {
	Header       string
	Package      string
	Imports      []fileImport
	DeepCopyCode string
}

type testTemplateData struct {
	Header     string
	Package    string
	Import     fileImport
	StructName string
}

type deepCopyTemplateData struct {
	StructName    string
	PackagePrefix string
	FieldCopies   string
}

const (
	structTemplateText   = `{{.OutPath}} = {{.PackagePrefix}}{{.TypeString}}{}`
	basicTemplateText    = `{{.OutPath}} = {{.InPath}}`
	selectorTemplateText = `{{.OutPath}} = {{.Alias}}.{{.SelectorName}}`
	arrayTemplateText    = `
if {{.InPath}} != nil {
	{{.OutPath}} = make({{.TypeString}}, len({{.InPath}}))
	{{- if .IsStruct }}
		for i := range {{.InPath}} {
			{{.ElemCopy}}
		}
	{{- else }}
		copy({{.OutPath}}, {{.InPath}})
	{{- end }}
}`
	mapTemplateText = `
if {{.InPath}} != nil {
	{{.OutPath}} = make({{.TypeString}}, len({{.InPath}}))
	for k, v := range {{.InPath}} {
		{{- if .IsStruct }}{{.ElemCopy}}{{- else }}{{.OutPath}}[k] = v{{- end }}
	}
}`
	starTemplateText = `
if {{.InPath}} != nil {
	{{- if .IsStruct }}
		{{.OutPath}} = new({{.PackagePrefix}}{{.TypeString}})
		{{.ElemCopy}}
	{{- else }}
		{{.OutPath}} = new({{.TypeString}})
		 *{{.OutPath}} = *{{.InPath}}
	{{- end }}
}`
	defaultTemplateText = `{{.OutPath}} = {{.InPath}}`
	fileTemplateText    = `// Code generated by gen/copy. DO NOT EDIT.

package {{.Package}}

{{if .Imports}}
import (
{{- range .Imports}}
{{- if and (ne .Alias "") (ne .Alias "_")}}
	{{.Alias}} "{{.Path}}"
{{- else}}
	"{{.Path}}"
{{- end}}
{{- end}}
)
{{end}}

{{.DeepCopyCode}}
`
	testTemplateText = `// Code generated by gen/copy. DO NOT EDIT.
	
package {{.Package}}
import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"pgregory.net/rapid"
	{{ .Import.Alias }} "{{ .Import.Path }}"

	"github.com/redpanda-data/redpanda-operator/pkg/rapidutil"
)

func TestDeepCopy{{.StructName}}(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		original := rapid.MakeCustom[{{ .Import.Alias }}.{{.StructName}}](rapidutil.KubernetesTypes).Draw(t, "original")

		// Marshal the original
		originalBytes, err := json.Marshal(original)
		require.NoError(t, err)

		// Deep copy
		copy := DeepCopy{{.StructName}}(&original)
		require.NotNil(t, copy)

		// Marshal the copy
		copyBytes, err := json.Marshal(copy)
		require.NoError(t, err)

		// Compare JSON
		assert.JSONEq(t, string(originalBytes), string(copyBytes), "DeepCopy{{.StructName}} did not copy all fields correctly")
	})
}
`
	deepCopyTemplateText = `func DeepCopy{{.StructName}}(in *{{.PackagePrefix}}{{.StructName}}) *{{.PackagePrefix}}{{.StructName}} {
	if in == nil {
		return nil
	}
	out := &{{.PackagePrefix}}{{.StructName}}{}
{{.FieldCopies}}
	return out
}`
)

var (
	structTemplate   *template.Template
	basicTemplate    *template.Template
	selectorTemplate *template.Template
	arrayTemplate    *template.Template
	mapTemplate      *template.Template
	starTemplate     *template.Template
	defaultTemplate  *template.Template
	fileTemplate     *template.Template
	deepCopyTemplate *template.Template
	testTemplate     *template.Template
)

func init() {
	structTemplate = template.Must(template.New("struct").Parse(structTemplateText))
	basicTemplate = template.Must(template.New("basic").Parse(basicTemplateText))
	selectorTemplate = template.Must(template.New("selector").Parse(selectorTemplateText))
	arrayTemplate = template.Must(template.New("array").Parse(arrayTemplateText))
	mapTemplate = template.Must(template.New("map").Parse(mapTemplateText))
	starTemplate = template.Must(template.New("star").Parse(starTemplateText))
	defaultTemplate = template.Must(template.New("default").Parse(defaultTemplateText))
	fileTemplate = template.Must(template.New("file").Parse(fileTemplateText))
	deepCopyTemplate = template.Must(template.New("deepCopy").Parse(deepCopyTemplateText))
	testTemplate = template.Must(template.New("test").Parse(testTemplateText))
}

func Cmd() *cobra.Command {
	var outFlag string
	var headerFlag string
	var structFlag string
	var outPackage string
	var testFlag string

	cmd := &cobra.Command{
		Use:     "applyconfig-copy [pkg]",
		Args:    cobra.ExactArgs(1),
		Example: "applyconfig-copy [--header ./path/to/license] [--package redpanda] --struct Values ./charts/redpanda",
		Run: func(cmd *cobra.Command, args []string) {
			run(args, outFlag, outPackage, headerFlag, structFlag, testFlag)
		},
	}

	cmd.Flags().StringVar(&outFlag, "out", "-", "The file to output to or `-` for stdout")
	cmd.Flags().StringVar(&outPackage, "package", "", "The package name to use for the output file. Defaults to the input package.")
	cmd.Flags().StringVar(&headerFlag, "header", "", "A file that will be used as a header for the generated file")
	cmd.Flags().StringVar(&structFlag, "struct", "", "The struct name to generate a partial for")
	cmd.Flags().StringVar(&testFlag, "test", "", "The output location for a test of the DeepCopy function for the specified struct")

	return cmd
}

func run(args []string, outFlag, outPackage, headerFlag, structFlag, testFlag string) {
	if structFlag == "" {
		fmt.Fprintf(os.Stderr, "--struct is required\n")
		os.Exit(1)
	}

	parser, err := Parse(args[0], outPackage, structFlag)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing package: %v\n", err)
		os.Exit(1)
	}

	generator := parser.Generator()
	code, err := generator.Generate()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating DeepCopy code: %v\n", err)
		os.Exit(1)
	}

	// Generate test if requested
	if testFlag != "" {
		testCode, err := generator.GenerateTest()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error generating DeepCopy test code: %v\n", err)
			os.Exit(1)
		}

		if headerFlag != "" {
			header, err := os.ReadFile(headerFlag)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error reading header file: %v\n", err)
				os.Exit(1)
			}
			testCode = string(header) + "\n" + testCode
		}

		err = os.WriteFile(testFlag, []byte(testCode), 0o644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing test file: %v\n", err)
			os.Exit(1)
		}
	}

	// Add header if provided
	if headerFlag != "" {
		header, err := os.ReadFile(headerFlag)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading header file: %v\n", err)
			os.Exit(1)
		}
		code = string(header) + "\n" + code
	}

	// Output
	if outFlag == "-" {
		fmt.Print(code)
	} else {
		err := os.WriteFile(outFlag, []byte(code), 0o644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
			os.Exit(1)
		}
	}
}

type Parser struct {
	inputPackage     string
	inputPackagePath string
	packageName      string
	structName       string
	structType       *ast.StructType
	processed        map[string]struct{}
	imports          map[string]string
	structTypes      map[structIdentifier]packageStruct
}

func Parse(inputPackagePath, packageName, structName string) (*Parser, error) {
	pkgs, err := packages.Load(loadConfig, inputPackagePath)
	if err != nil {
		return nil, err
	}

	if len(pkgs) != 1 {
		return nil, fmt.Errorf("expected exactly one package, found %d", len(pkgs))
	}

	pkg := pkgs[0]
	if len(pkg.Errors) > 0 {
		var err error
		for _, pkgErr := range pkg.Errors {
			err = errors.Join(err, pkgErr)
		}
		return nil, err
	}

	parts := strings.Split(pkg.PkgPath, "/")
	inputPackage := strings.Join(parts[len(parts)-2:], "") + "ac"

	p := &Parser{
		inputPackage:     inputPackage,
		inputPackagePath: inputPackagePath,
		packageName:      packageName,
		structName:       structName,
		processed:        make(map[string]struct{}),
		imports:          make(map[string]string),
		structTypes:      make(map[structIdentifier]packageStruct),
	}

	if err := p.collect(pkg.PkgPath); err != nil {
		return nil, err
	}

	structType, ok := p.structTypes[structIdentifier{packagePath: pkg.PkgPath, structName: structName}]
	if !ok {
		return nil, fmt.Errorf("Struct %s not found in package %s\n", structName, pkg.PkgPath)
	}
	p.structType = structType.structType

	return p, nil
}

func (p *Parser) collect(basePackage string) error {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}, basePackage)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		if _, ok := p.processed[pkg.PkgPath]; ok {
			continue
		}

		if err := p.collectStructTypes(pkg); err != nil {
			return err
		}
		if err := p.collectImports(pkg); err != nil {
			return err
		}
		p.processed[pkg.PkgPath] = struct{}{}
	}

	for _, importName := range p.imports {
		if _, ok := p.processed[importName]; ok {
			continue
		}
		if err := p.collect(importName); err != nil {
			return err
		}
	}

	return nil
}

func (p *Parser) collectImports(pkg *packages.Package) error {
	if _, ok := p.processed[pkg.PkgPath]; ok {
		return nil
	}

	for _, file := range pkg.Syntax {
		for _, imp := range file.Imports {
			importPath := strings.Trim(imp.Path.Value, "\"")
			if !strings.Contains(importPath, "k8s.io/apimachinery/pkg/api") &&
				!strings.Contains(importPath, "k8s.io/apimachinery/pkg/util/intstr") &&
				!strings.Contains(importPath, "k8s.io/api/core/v1") &&
				!strings.Contains(importPath, "k8s.io/client-go/applyconfigurations") {
				// we only care about k8s apimachinery and client-go applyconfigurations imports
				continue
			}

			alias := ""
			if imp.Name != nil {
				alias = imp.Name.Name
				if strings.Contains(importPath, "applyconfiguration") {
					// add in ac for conflicts
					alias = alias + "ac"
				}
			} else {
				// Default alias is last element of import path
				parts := strings.Split(importPath, "/")
				alias = parts[len(parts)-1]
				last := alias[len(alias)-1]
				if _, err := strconv.ParseInt(string(last), 10, 64); err == nil {
					alias = strings.Join(parts[len(parts)-2:], "")
				}
			}
			i := 2
			for existingPath, exists := p.imports[alias]; exists && existingPath != importPath; i++ {
				parts := strings.Split(importPath, "/")
				if len(parts) < i {
					return fmt.Errorf("import alias conflict: %s maps to both %s and %s", alias, existingPath, importPath)
				}
				alias = parts[len(parts)-i] + alias
				existingPath, exists = p.imports[alias]
			}
			p.imports[alias] = importPath
			p.imports[importPath] = alias
		}
	}

	return nil
}

type structIdentifier struct {
	packagePath string
	structName  string
}

type packageStruct struct {
	packagePath string
	structType  *ast.StructType
}

func (p *Parser) collectStructTypes(pkg *packages.Package) error {
	if _, ok := p.processed[pkg.PkgPath]; ok {
		return nil
	}

	var err error
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if ts, ok := n.(*ast.TypeSpec); ok {
				if st, ok := ts.Type.(*ast.StructType); ok {
					name := ts.Name.Name
					if old, exists := p.structTypes[structIdentifier{packagePath: pkg.PkgPath, structName: name}]; exists {
						err = fmt.Errorf("struct type conflict: %s defined in multiple packages: %q and %q", name, old.packagePath, pkg.PkgPath)
						return false
					}
					p.structTypes[structIdentifier{packagePath: pkg.PkgPath, structName: name}] = packageStruct{
						packagePath: pkg.PkgPath,
						structType:  st,
					}
				}
			}
			return true
		})
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *Parser) Generator() *Generator {
	return &Generator{
		packagePrefix:    p.inputPackage + ".",
		packageName:      p.packageName,
		structName:       p.structName,
		inputPackage:     p.inputPackage,
		inputPackagePath: p.inputPackagePath,
		imports:          p.imports,
		structType:       p.structType,
		structTypes:      p.structTypes,
		usedImports: map[string]string{
			p.inputPackage: p.inputPackagePath,
		},
	}
}

type Generator struct {
	packagePrefix    string
	packageName      string
	inputPackage     string
	inputPackagePath string
	structName       string
	structType       *ast.StructType
	imports          map[string]string
	structTypes      map[structIdentifier]packageStruct
	usedImports      map[string]string
}

func (g *Generator) GenerateTest() (string, error) {
	var buf strings.Builder
	if err := testTemplate.Execute(&buf, testTemplateData{
		Package:    g.packageName,
		Import:     fileImport{Alias: g.inputPackage, Path: g.inputPackagePath},
		StructName: g.structName,
	}); err != nil {
		return "", err
	}

	src := buf.String()
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return "", err
	}

	return string(formatted), nil
}

func (g *Generator) Generate() (string, error) {
	deepCopyCode, err := g.generateDeepCopy()
	if err != nil {
		return "", err
	}

	importsList := []fileImport{}
	for alias, path := range g.usedImports {
		importsList = append(importsList, fileImport{Alias: alias, Path: path})
	}

	var buf strings.Builder
	if err := fileTemplate.Execute(&buf, fileTemplateData{
		Package:      g.packageName,
		Imports:      importsList,
		DeepCopyCode: deepCopyCode,
	}); err != nil {
		return "", err
	}

	src := buf.String()
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return "", err
	}
	return string(formatted), nil
}

func (g *Generator) generateDeepCopy() (string, error) {
	var fieldCopies strings.Builder
	for _, field := range g.structType.Fields.List {
		if field.Names == nil {
			typeName := ""
			switch t := field.Type.(type) {
			case *ast.Ident:
				typeName = t.Name
			case *ast.SelectorExpr:
				typeName = t.Sel.Name
			}
			if typeName != "" {
				if err := g.generateCopy(&fieldCopies, fmt.Sprintf("in.%s", typeName), fmt.Sprintf("out.%s", typeName), "", field.Type, false); err != nil {
					return "", err
				}
			}
			continue
		}
		for _, name := range field.Names {
			fieldName := name.Name
			if err := g.generateCopy(&fieldCopies, fmt.Sprintf("in.%s", fieldName), fmt.Sprintf("out.%s", fieldName), "", field.Type, false); err != nil {
				return "", err
			}
		}
	}
	// Use deepCopyFuncTemplateText for the struct DeepCopy function
	var buf strings.Builder
	if err := deepCopyTemplate.Execute(&buf, deepCopyTemplateData{
		StructName:    g.structName,
		PackagePrefix: g.packagePrefix,
		FieldCopies:   fieldCopies.String(),
	}); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func (g *Generator) generateCopy(buf *strings.Builder, inPath, outPath, knownPkg string, expr ast.Expr, skipInitial bool) error {
	switch t := expr.(type) {
	case *ast.Ident:
		packagePath := g.inputPackagePath
		if knownPkg != "" {
			packagePath = g.imports[knownPkg]
		}
		if st, ok := g.structTypes[structIdentifier{packagePath: packagePath, structName: t.Name}]; ok {
			var fieldCopies strings.Builder
			for _, field := range st.structType.Fields.List {
				if field.Names == nil {
					typeName := ""
					switch t := field.Type.(type) {
					case *ast.Ident:
						typeName = t.Name
					case *ast.SelectorExpr:
						typeName = t.Sel.Name
					case *ast.StarExpr:
						switch xt := t.X.(type) {
						case *ast.Ident:
							typeName = xt.Name
						case *ast.SelectorExpr:
							typeName = xt.Sel.Name
						}
					}
					if typeName != "" {
						subIn := fmt.Sprintf("(%s).%s", inPath, typeName)
						subOut := fmt.Sprintf("(%s).%s", outPath, typeName)
						fieldCopies.WriteString("\n")
						if err := g.generateCopy(&fieldCopies, subIn, subOut, knownPkg, field.Type, false); err != nil {
							return err
						}
					}
					continue
				}
				for _, name := range field.Names {
					subIn := fmt.Sprintf("(%s).%s", inPath, name.Name)
					subOut := fmt.Sprintf("(%s).%s", outPath, name.Name)
					fieldCopies.WriteString("\n")
					if err := g.generateCopy(&fieldCopies, subIn, subOut, knownPkg, field.Type, false); err != nil {
						return err
					}
				}
			}
			if !skipInitial {
				if err := structTemplate.Execute(buf, copyTemplateData{
					OutPath:       outPath,
					PackagePrefix: g.packagePrefix,
					TypeString:    t.Name,
				}); err != nil {
					return err
				}
			}
			buf.WriteString(fieldCopies.String())
		} else {
			name := t.Name
			if knownPkg != "" {
				name = knownPkg
			}
			if path, ok := g.imports[name]; ok && path != "" {
				g.usedImports[name] = path
			}
			if err := basicTemplate.Execute(buf, copyTemplateData{
				OutPath: outPath,
				InPath:  inPath,
			}); err != nil {
				return err
			}
		}
	case *ast.SelectorExpr:
		if err := g.handleSelectorExprCopy(buf, t, inPath, outPath, knownPkg, skipInitial); err != nil {
			return err
		}
	case *ast.ArrayType:
		if err := g.handleArrayCopy(buf, t, inPath, outPath, knownPkg); err != nil {
			return err
		}
	case *ast.MapType:
		if err := g.handleMapCopy(buf, t, inPath, outPath, knownPkg); err != nil {
			return err
		}
	case *ast.StarExpr:
		if err := g.handleStarExprCopy(buf, t, inPath, outPath); err != nil {
			return err
		}
	default:
		if !skipInitial {
			if err := g.handleDefaultCopy(buf, inPath, outPath); err != nil {
				return err
			}
		}
	}
	return nil
}

func (g *Generator) handleSelectorExprCopy(buf *strings.Builder, t *ast.SelectorExpr, inPath, outPath, knownPkg string, skipInitial bool) error {
	if !skipInitial {
		if err := selectorTemplate.Execute(buf, copyTemplateData{
			OutPath:      outPath,
			Alias:        knownPkg,
			SelectorName: t.Sel.Name,
		}); err != nil {
			return err
		}
	}

	return g.generateCopy(buf, inPath, outPath, knownPkg, t.X, false)
}

func (g *Generator) handleArrayCopy(buf *strings.Builder, t *ast.ArrayType, inPath, outPath, knownPkg string) error {
	var elemCopy string
	if g.isStructType(t.Elt, knownPkg) {
		var copyElements strings.Builder
		copyElements.WriteString(fmt.Sprintf("in, out := &%s[i], &%s[i]\n", inPath, outPath))
		if err := g.generateCopy(&copyElements, "in", "out", knownPkg, t.Elt, true); err != nil {
			return err
		}
		elemCopy = copyElements.String()
	}

	return arrayTemplate.Execute(buf, copyTemplateData{
		InPath:     inPath,
		OutPath:    outPath,
		TypeString: g.typeString(t, g.packagePrefix),
		IsStruct:   g.isStructType(t.Elt, knownPkg),
		ElemCopy:   elemCopy,
	})
}

func (g *Generator) handleMapCopy(buf *strings.Builder, t *ast.MapType, inPath, outPath, knownPkg string) error {
	var elemCopy string
	isStruct := g.isStructType(t.Value, knownPkg)
	if isStruct {
		var copyElements strings.Builder
		copyElements.WriteString(fmt.Sprintf("in, out := &v, &%s[k]\n", outPath))
		if err := g.generateCopy(&copyElements, "in", "out", knownPkg, t.Value, true); err != nil {
			return err
		}
		elemCopy = copyElements.String()
	}

	return mapTemplate.Execute(buf, copyTemplateData{
		InPath: inPath, OutPath: outPath,
		TypeString: g.typeString(t, g.packagePrefix),
		IsStruct:   isStruct,
		ElemCopy:   elemCopy,
	})
}

func (g *Generator) handleStarExprCopy(buf *strings.Builder, t *ast.StarExpr, inPath, outPath string) error {
	prefix := g.packagePrefix
	knownPkg := ""
	typeString := g.typeString(t.X, "")
	if strings.Contains(typeString, ".") {
		prefix = ""
		parts := strings.Split(typeString, ".")
		knownPkg = parts[0]
	}

	var elemCopy string
	isStruct := g.isStructType(t.X, knownPkg)
	if isStruct {
		var copyElements strings.Builder
		if err := g.generateCopy(&copyElements, fmt.Sprintf("*%s", inPath), fmt.Sprintf("*%s", outPath), knownPkg, t.X, true); err != nil {
			return err
		}
		elemCopy = copyElements.String()
	}

	return starTemplate.Execute(buf, copyTemplateData{
		InPath:        inPath,
		OutPath:       outPath,
		TypeString:    typeString,
		PackagePrefix: prefix,
		IsStruct:      isStruct,
		ElemCopy:      elemCopy,
	})
}

func (g *Generator) handleDefaultCopy(buf *strings.Builder, inPath, outPath string) error {
	return defaultTemplate.Execute(buf, copyTemplateData{
		OutPath: outPath,
		InPath:  inPath,
	})
}

func (g *Generator) isStructType(expr ast.Expr, knownPackage string) bool {
	switch t := expr.(type) {
	case *ast.Ident:
		packagePath := g.inputPackagePath
		if knownPackage != "" {
			packagePath = g.imports[knownPackage]
		}
		_, ok := g.structTypes[structIdentifier{packagePath: packagePath, structName: t.Name}]
		return ok
	case *ast.StarExpr:
		knownPkg := ""
		typeString := g.typeString(t.X, "")
		if strings.Contains(typeString, ".") {
			parts := strings.Split(typeString, ".")
			knownPkg = parts[0]
		}
		return g.isStructType(t.X, knownPkg)
	case *ast.SelectorExpr:
		// Try to resolve qualified name for imported struct
		if ident, ok := t.X.(*ast.Ident); ok {
			_, ok := g.structTypes[structIdentifier{packagePath: g.imports[ident.Name], structName: t.Sel.Name}]
			return ok || strings.HasSuffix(t.Sel.Name, "ApplyConfiguration")
		}
		return false
	default:
		return false
	}
}

func (g *Generator) typeString(expr ast.Expr, prefix string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64",
			"string", "bool",
			"byte", "rune":
			return t.Name
		default:
			return prefix + t.Name
		}
	case *ast.ArrayType:
		return "[]" + g.typeString(t.Elt, prefix)
	case *ast.MapType:
		return "map[" + g.typeString(t.Key, prefix) + "]" + g.typeString(t.Value, prefix)
	case *ast.StarExpr:
		return "*" + g.typeString(t.X, prefix)
	case *ast.SelectorExpr:
		alias := ""
		if ident, ok := t.X.(*ast.Ident); ok {
			name := normalizeAlias(ident.Name, t.Sel.Name)
			if path, ok := g.imports[name]; ok && path != "" {
				g.usedImports[name] = path
				alias = name
			} else {
				alias = name
			}
		}
		if alias != "" {
			return alias + "." + t.Sel.Name
		}
		return prefix + t.Sel.Name
	default:
		panic("unhandled type")
	}
}

func normalizeAlias(packageName, structName string) string {
	if strings.Contains(structName, "ApplyConfiguration") {
		return packageName + "ac"
	}
	return packageName
}
