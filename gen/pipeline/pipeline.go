package pipeline

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/buildkite/go-pipeline"
	"github.com/buildkite/go-pipeline/ordered"
	"github.com/spf13/cobra"
	"k8s.io/utils/ptr"
	"sigs.k8s.io/yaml"
)

//nolint:stylecheck // SCREAMING_CASE for pseudo consts is acceptable.
var (
	// Known/Permitted environment variables pulled from AWS secret store.

	GITHUB_API_TOKEN               = secretEnvVar{SecretID: "sdlc/prod/buildkite/github_api_token"}
	REDPANDA_SAMPLE_LICENSE        = secretEnvVar{SecretID: "sdlc/prod/buildkite/redpanda_sample_license"}
	REDPANDA_SECOND_SAMPLE_LICENSE = secretEnvVar{SecretID: "sdlc/prod/buildkite/redpanda_second_sample_license"}
	SLACK_VBOT_TOKEN               = secretEnvVar{SecretID: "sdlc/prod/buildkite/slack_vbot_token"}

	// Known/Permitted Agent Pools

	AgentsPipeLineUploader = map[string]any{"queue": "pipeline-uploader"}
	AgentsLarge            = map[string]any{"queue": "k8s-m6id12xlarge"}
)

var suites = []TestSuite{
	{
		Name:     "unit",
		Required: true,
		Timeout:  15 * time.Minute,
	},
	{
		Name:     "integration",
		Required: true,
		Timeout:  30*time.Minute + time.Hour,
	},
	{
		Name:     "acceptance",
		Required: true,
		Timeout:  time.Hour,
	},
	// kuttl-v1 is currently the slowest and flakiest of our test suites. The
	// majority of changes made aren't exercised by this suite. It runs conditionally
	// until we have time to speed it up and deflake it.
	{
		Name:         "kuttl-v1",
		Required:     true,
		Timeout:      30*time.Minute + time.Hour,
		JUnitPattern: ptr.To("work/operator/tests/_e2e_artifacts/kuttl-report.xml"),
		Condition:    `build.pull_request.labels includes "run-kuttl-v1"`,
	},
	{
		Name:         "kuttl-v1-nodepools",
		Required:     true,
		Timeout:      30 * time.Minute,
		JUnitPattern: ptr.To("work/operator/tests/_e2e_with_flags_artifacts/kuttl-report.xml"),
	},
}

func Cmd() *cobra.Command {
	return &cobra.Command{
		Use:   "pipeline [name]",
		Short: "Generate BuildKite pipelines",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			var pipeline *pipeline.Pipeline

			switch args[0] {
			case "testsuite":
				pipeline = testSuitePipeline()
			default:
				fmt.Fprintf(cmd.OutOrStderr(), "unknown pipeline %q", args[0])
				os.Exit(1)
			}

			out, err := yaml.Marshal(pipeline)
			if err != nil {
				panic(err)
			}

			invocation := strings.Join(os.Args, " ")
			fmt.Fprintf(cmd.OutOrStdout(), "# DO NOT EDIT. FILE GENERATED BY %s.\n---\n%s\n", invocation, out)
		},
	}
}

func testSuitePipeline() *pipeline.Pipeline {
	p := &pipeline.Pipeline{
		Env: ordered.MapFromItems(
			// CI runs podman instead of docker. testcontainer's ryuk is reported to not
			// work well with podman so we disable it in CI.
			ordered.Tuple[string, string]{Key: "TESTCONTAINERS_RYUK_DISABLED", Value: "true"},
		),
		RemainingFields: map[string]any{
			// NB: This notify configuration serves as the aggregate state of this
			// entire pipeline. The string in context is what github is configured to
			// block PRs on. The step level notify blocks are to provide feedback in
			// GH's UI only. If a step/suite becomes flakey, it can be marked as
			// optional by setting `soft_fail: true`.
			// See also:
			// - https://buildkite.com/docs/pipelines/source-control/github#customizing-commit-statuses
			"notify": []any{
				NotifyGitHubCommitStatus{Context: "Operator Test Suite"},
				// HACK: Until we update GH's required checks setting we report
				// the status of this pipeline to all required checks.
				NotifyGitHubCommitStatus{Context: "k8s-operator-v2"},
				NotifyGitHubCommitStatus{Context: "k8s-operator-v2-helm"},
			},
		},
		Steps: pipeline.Steps{
			&pipeline.CommandStep{
				Key:     "lint",
				Label:   "Lint",
				Command: "./ci/scripts/run-in-nix-docker.sh task ci:configure ci:lint",
				RemainingFields: map[string]any{
					"timeout_in_minutes": 10,
					"agents":             AgentsLarge,
					"notify": []any{
						NotifyGitHubCommitStatus{Context: "Lint"},
					},
				},
				Plugins: pipeline.Plugins{
					secretEnvVars(GITHUB_API_TOKEN),
				},
			},
		},
	}

	for _, suite := range suites {
		p.Steps = append(p.Steps, suite.ToStep())
	}

	return p
}
