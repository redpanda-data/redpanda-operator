//go:build !ignore_autogenerated

// Copyright 2024 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha2

import (
	"github.com/fluxcd/helm-controller/api/v2beta2"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"github.com/redpanda-data/redpanda-operator/operator/api/apiutil"
	"k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ACLResourceSpec) DeepCopyInto(out *ACLResourceSpec) {
	*out = *in
	if in.PatternType != nil {
		in, out := &in.PatternType, &out.PatternType
		*out = new(PatternType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ACLResourceSpec.
func (in *ACLResourceSpec) DeepCopy() *ACLResourceSpec {
	if in == nil {
		return nil
	}
	out := new(ACLResourceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ACLRule) DeepCopyInto(out *ACLRule) {
	*out = *in
	in.Resource.DeepCopyInto(&out.Resource)
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.Operations != nil {
		in, out := &in.Operations, &out.Operations
		*out = make([]ACLOperation, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ACLRule.
func (in *ACLRule) DeepCopy() *ACLRule {
	if in == nil {
		return nil
	}
	out := new(ACLRule)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Admin) DeepCopyInto(out *Admin) {
	*out = *in
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = make(map[string]*ExternalListener, len(*in))
		for key, val := range *in {
			var outVal *ExternalListener
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(ExternalListener)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.AppProtocol != nil {
		in, out := &in.AppProtocol, &out.AppProtocol
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Admin.
func (in *Admin) DeepCopy() *Admin {
	if in == nil {
		return nil
	}
	out := new(Admin)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdminAPISpec) DeepCopyInto(out *AdminAPISpec) {
	*out = *in
	if in.URLs != nil {
		in, out := &in.URLs, &out.URLs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(CommonTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.SASL != nil {
		in, out := &in.SASL, &out.SASL
		*out = new(AdminSASL)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdminAPISpec.
func (in *AdminAPISpec) DeepCopy() *AdminAPISpec {
	if in == nil {
		return nil
	}
	out := new(AdminAPISpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdminSASL) DeepCopyInto(out *AdminSASL) {
	*out = *in
	out.Password = in.Password
	out.AuthToken = in.AuthToken
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdminSASL.
func (in *AdminSASL) DeepCopy() *AdminSASL {
	if in == nil {
		return nil
	}
	out := new(AdminSASL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuditLogging) DeepCopyInto(out *AuditLogging) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Listener != nil {
		in, out := &in.Listener, &out.Listener
		*out = new(string)
		**out = **in
	}
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(int)
		**out = **in
	}
	if in.EnabledEventTypes != nil {
		in, out := &in.EnabledEventTypes, &out.EnabledEventTypes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExcludedTopics != nil {
		in, out := &in.ExcludedTopics, &out.ExcludedTopics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExcludedPrincipals != nil {
		in, out := &in.ExcludedPrincipals, &out.ExcludedPrincipals
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ClientMaxBufferSize != nil {
		in, out := &in.ClientMaxBufferSize, &out.ClientMaxBufferSize
		*out = new(int)
		**out = **in
	}
	if in.QueueDrainIntervalMs != nil {
		in, out := &in.QueueDrainIntervalMs, &out.QueueDrainIntervalMs
		*out = new(int)
		**out = **in
	}
	if in.QueueMaxBufferSizePerShard != nil {
		in, out := &in.QueueMaxBufferSizePerShard, &out.QueueMaxBufferSizePerShard
		*out = new(int)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuditLogging.
func (in *AuditLogging) DeepCopy() *AuditLogging {
	if in == nil {
		return nil
	}
	out := new(AuditLogging)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Auth) DeepCopyInto(out *Auth) {
	*out = *in
	if in.SASL != nil {
		in, out := &in.SASL, &out.SASL
		*out = new(SASL)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Auth.
func (in *Auth) DeepCopy() *Auth {
	if in == nil {
		return nil
	}
	out := new(Auth)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BootstrapUser) DeepCopyInto(out *BootstrapUser) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.SecretKeyRef != nil {
		in, out := &in.SecretKeyRef, &out.SecretKeyRef
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Mechanism != nil {
		in, out := &in.Mechanism, &out.Mechanism
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BootstrapUser.
func (in *BootstrapUser) DeepCopy() *BootstrapUser {
	if in == nil {
		return nil
	}
	out := new(BootstrapUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Budget) DeepCopyInto(out *Budget) {
	*out = *in
	if in.MaxUnavailable != nil {
		in, out := &in.MaxUnavailable, &out.MaxUnavailable
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Budget.
func (in *Budget) DeepCopy() *Budget {
	if in == nil {
		return nil
	}
	out := new(Budget)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CPU) DeepCopyInto(out *CPU) {
	*out = *in
	if in.Cores != nil {
		in, out := &in.Cores, &out.Cores
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.Overprovisioned != nil {
		in, out := &in.Overprovisioned, &out.Overprovisioned
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CPU.
func (in *CPU) DeepCopy() *CPU {
	if in == nil {
		return nil
	}
	out := new(CPU)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Certificate) DeepCopyInto(out *Certificate) {
	*out = *in
	if in.IssuerRef != nil {
		in, out := &in.IssuerRef, &out.IssuerRef
		*out = new(IssuerRef)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretRef != nil {
		in, out := &in.SecretRef, &out.SecretRef
		*out = new(SecretRef)
		(*in).DeepCopyInto(*out)
	}
	if in.ClientSecretRef != nil {
		in, out := &in.ClientSecretRef, &out.ClientSecretRef
		*out = new(SecretRef)
		(*in).DeepCopyInto(*out)
	}
	if in.Duration != nil {
		in, out := &in.Duration, &out.Duration
		*out = new(metav1.Duration)
		**out = **in
	}
	if in.CAEnabled != nil {
		in, out := &in.CAEnabled, &out.CAEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ApplyInternalDNSNames != nil {
		in, out := &in.ApplyInternalDNSNames, &out.ApplyInternalDNSNames
		*out = new(bool)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Certificate.
func (in *Certificate) DeepCopy() *Certificate {
	if in == nil {
		return nil
	}
	out := new(Certificate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChartRef) DeepCopyInto(out *ChartRef) {
	*out = *in
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(metav1.Duration)
		**out = **in
	}
	if in.Upgrade != nil {
		in, out := &in.Upgrade, &out.Upgrade
		*out = new(HelmUpgrade)
		(*in).DeepCopyInto(*out)
	}
	if in.UseFlux != nil {
		in, out := &in.UseFlux, &out.UseFlux
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChartRef.
func (in *ChartRef) DeepCopy() *ChartRef {
	if in == nil {
		return nil
	}
	out := new(ChartRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterRef) DeepCopyInto(out *ClusterRef) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterRef.
func (in *ClusterRef) DeepCopy() *ClusterRef {
	if in == nil {
		return nil
	}
	out := new(ClusterRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterSource) DeepCopyInto(out *ClusterSource) {
	*out = *in
	if in.ClusterRef != nil {
		in, out := &in.ClusterRef, &out.ClusterRef
		*out = new(ClusterRef)
		**out = **in
	}
	if in.StaticConfiguration != nil {
		in, out := &in.StaticConfiguration, &out.StaticConfiguration
		*out = new(StaticConfigurationSource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterSource.
func (in *ClusterSource) DeepCopy() *ClusterSource {
	if in == nil {
		return nil
	}
	out := new(ClusterSource)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CommonTLS) DeepCopyInto(out *CommonTLS) {
	*out = *in
	if in.CaCert != nil {
		in, out := &in.CaCert, &out.CaCert
		*out = new(SecretKeyRef)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(SecretKeyRef)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(SecretKeyRef)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CommonTLS.
func (in *CommonTLS) DeepCopy() *CommonTLS {
	if in == nil {
		return nil
	}
	out := new(CommonTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Config) DeepCopyInto(out *Config) {
	*out = *in
	if in.RPK != nil {
		in, out := &in.RPK, &out.RPK
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Cluster != nil {
		in, out := &in.Cluster, &out.Cluster
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Node != nil {
		in, out := &in.Node, &out.Node
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Tunable != nil {
		in, out := &in.Tunable, &out.Tunable
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.SchemaRegistryClient != nil {
		in, out := &in.SchemaRegistryClient, &out.SchemaRegistryClient
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.PandaProxyClient != nil {
		in, out := &in.PandaProxyClient, &out.PandaProxyClient
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Config.
func (in *Config) DeepCopy() *Config {
	if in == nil {
		return nil
	}
	out := new(Config)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigSynonyms) DeepCopyInto(out *ConfigSynonyms) {
	*out = *in
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
	if in.UnknownTags != nil {
		in, out := &in.UnknownTags, &out.UnknownTags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigSynonyms.
func (in *ConfigSynonyms) DeepCopy() *ConfigSynonyms {
	if in == nil {
		return nil
	}
	out := new(ConfigSynonyms)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigWatcher) DeepCopyInto(out *ConfigWatcher) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigWatcher.
func (in *ConfigWatcher) DeepCopy() *ConfigWatcher {
	if in == nil {
		return nil
	}
	out := new(ConfigWatcher)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Configuration) DeepCopyInto(out *Configuration) {
	*out = *in
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
	if in.ConfigSynonyms != nil {
		in, out := &in.ConfigSynonyms, &out.ConfigSynonyms
		*out = make([]ConfigSynonyms, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Documentation != nil {
		in, out := &in.Documentation, &out.Documentation
		*out = new(string)
		**out = **in
	}
	if in.UnknownTags != nil {
		in, out := &in.UnknownTags, &out.UnknownTags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Configuration.
func (in *Configuration) DeepCopy() *Configuration {
	if in == nil {
		return nil
	}
	out := new(Configuration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Configurator) DeepCopyInto(out *Configurator) {
	*out = *in
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Configurator.
func (in *Configurator) DeepCopy() *Configurator {
	if in == nil {
		return nil
	}
	out := new(Configurator)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectorMonitoring) DeepCopyInto(out *ConnectorMonitoring) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScrapeInterval != nil {
		in, out := &in.ScrapeInterval, &out.ScrapeInterval
		*out = new(string)
		**out = **in
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NamespaceSelector != nil {
		in, out := &in.NamespaceSelector, &out.NamespaceSelector
		*out = new(monitoringv1.NamespaceSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectorMonitoring.
func (in *ConnectorMonitoring) DeepCopy() *ConnectorMonitoring {
	if in == nil {
		return nil
	}
	out := new(ConnectorMonitoring)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectorsCreateObj) DeepCopyInto(out *ConnectorsCreateObj) {
	*out = *in
	if in.Create != nil {
		in, out := &in.Create, &out.Create
		*out = new(bool)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectorsCreateObj.
func (in *ConnectorsCreateObj) DeepCopy() *ConnectorsCreateObj {
	if in == nil {
		return nil
	}
	out := new(ConnectorsCreateObj)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConsoleCreateObj) DeepCopyInto(out *ConsoleCreateObj) {
	*out = *in
	if in.Create != nil {
		in, out := &in.Create, &out.Create
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConsoleCreateObj.
func (in *ConsoleCreateObj) DeepCopy() *ConsoleCreateObj {
	if in == nil {
		return nil
	}
	out := new(ConsoleCreateObj)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Container) DeepCopyInto(out *Container) {
	*out = *in
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.Env != nil {
		in, out := &in.Env, &out.Env
		*out = make([]v1.EnvVar, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Container.
func (in *Container) DeepCopy() *Container {
	if in == nil {
		return nil
	}
	out := new(Container)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerResources) DeepCopyInto(out *ContainerResources) {
	*out = *in
	if in.Max != nil {
		in, out := &in.Max, &out.Max
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.Min != nil {
		in, out := &in.Min, &out.Min
		x := (*in).DeepCopy()
		*out = &x
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerResources.
func (in *ContainerResources) DeepCopy() *ContainerResources {
	if in == nil {
		return nil
	}
	out := new(ContainerResources)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CredentialSecretRef) DeepCopyInto(out *CredentialSecretRef) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(SecretWithConfigField)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretKey != nil {
		in, out := &in.SecretKey, &out.SecretKey
		*out = new(SecretWithConfigField)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CredentialSecretRef.
func (in *CredentialSecretRef) DeepCopy() *CredentialSecretRef {
	if in == nil {
		return nil
	}
	out := new(CredentialSecretRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Enablable) DeepCopyInto(out *Enablable) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Enablable.
func (in *Enablable) DeepCopy() *Enablable {
	if in == nil {
		return nil
	}
	out := new(Enablable)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Enterprise) DeepCopyInto(out *Enterprise) {
	*out = *in
	if in.License != nil {
		in, out := &in.License, &out.License
		*out = new(string)
		**out = **in
	}
	if in.LicenseSecretRef != nil {
		in, out := &in.LicenseSecretRef, &out.LicenseSecretRef
		*out = new(EnterpriseLicenseSecretRef)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Enterprise.
func (in *Enterprise) DeepCopy() *Enterprise {
	if in == nil {
		return nil
	}
	out := new(Enterprise)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EnterpriseLicenseSecretRef) DeepCopyInto(out *EnterpriseLicenseSecretRef) {
	*out = *in
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EnterpriseLicenseSecretRef.
func (in *EnterpriseLicenseSecretRef) DeepCopy() *EnterpriseLicenseSecretRef {
	if in == nil {
		return nil
	}
	out := new(EnterpriseLicenseSecretRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *External) DeepCopyInto(out *External) {
	*out = *in
	if in.Addresses != nil {
		in, out := &in.Addresses, &out.Addresses
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Domain != nil {
		in, out := &in.Domain, &out.Domain
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(ExternalService)
		(*in).DeepCopyInto(*out)
	}
	if in.SourceRanges != nil {
		in, out := &in.SourceRanges, &out.SourceRanges
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.ExternalDNS != nil {
		in, out := &in.ExternalDNS, &out.ExternalDNS
		*out = new(ExternalDNS)
		(*in).DeepCopyInto(*out)
	}
	if in.PrefixTemplate != nil {
		in, out := &in.PrefixTemplate, &out.PrefixTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new External.
func (in *External) DeepCopy() *External {
	if in == nil {
		return nil
	}
	out := new(External)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExternalDNS) DeepCopyInto(out *ExternalDNS) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExternalDNS.
func (in *ExternalDNS) DeepCopy() *ExternalDNS {
	if in == nil {
		return nil
	}
	out := new(ExternalDNS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExternalListener) DeepCopyInto(out *ExternalListener) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.AuthenticationMethod != nil {
		in, out := &in.AuthenticationMethod, &out.AuthenticationMethod
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.AdvertisedPorts != nil {
		in, out := &in.AdvertisedPorts, &out.AdvertisedPorts
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
	if in.PrefixTemplate != nil {
		in, out := &in.PrefixTemplate, &out.PrefixTemplate
		*out = new(string)
		**out = **in
	}
	if in.NodePort != nil {
		in, out := &in.NodePort, &out.NodePort
		*out = new(int32)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExternalListener.
func (in *ExternalListener) DeepCopy() *ExternalListener {
	if in == nil {
		return nil
	}
	out := new(ExternalListener)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExternalService) DeepCopyInto(out *ExternalService) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExternalService.
func (in *ExternalService) DeepCopy() *ExternalService {
	if in == nil {
		return nil
	}
	out := new(ExternalService)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FsValidator) DeepCopyInto(out *FsValidator) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExpectedFS != nil {
		in, out := &in.ExpectedFS, &out.ExpectedFS
		*out = new(string)
		**out = **in
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FsValidator.
func (in *FsValidator) DeepCopy() *FsValidator {
	if in == nil {
		return nil
	}
	out := new(FsValidator)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HTTP) DeepCopyInto(out *HTTP) {
	*out = *in
	if in.AuthenticationMethod != nil {
		in, out := &in.AuthenticationMethod, &out.AuthenticationMethod
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = make(map[string]*ExternalListener, len(*in))
		for key, val := range *in {
			var outVal *ExternalListener
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(ExternalListener)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.KafkaEndpoint != nil {
		in, out := &in.KafkaEndpoint, &out.KafkaEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.PrefixTemplate != nil {
		in, out := &in.PrefixTemplate, &out.PrefixTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTP.
func (in *HTTP) DeepCopy() *HTTP {
	if in == nil {
		return nil
	}
	out := new(HTTP)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmUpgrade) DeepCopyInto(out *HelmUpgrade) {
	*out = *in
	if in.Remediation != nil {
		in, out := &in.Remediation, &out.Remediation
		*out = new(v2beta2.UpgradeRemediation)
		(*in).DeepCopyInto(*out)
	}
	if in.Force != nil {
		in, out := &in.Force, &out.Force
		*out = new(bool)
		**out = **in
	}
	if in.PreserveValues != nil {
		in, out := &in.PreserveValues, &out.PreserveValues
		*out = new(bool)
		**out = **in
	}
	if in.CleanupOnFail != nil {
		in, out := &in.CleanupOnFail, &out.CleanupOnFail
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmUpgrade.
func (in *HelmUpgrade) DeepCopy() *HelmUpgrade {
	if in == nil {
		return nil
	}
	out := new(HelmUpgrade)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InitContainerImage) DeepCopyInto(out *InitContainerImage) {
	*out = *in
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(string)
		**out = **in
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InitContainerImage.
func (in *InitContainerImage) DeepCopy() *InitContainerImage {
	if in == nil {
		return nil
	}
	out := new(InitContainerImage)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InitContainers) DeepCopyInto(out *InitContainers) {
	*out = *in
	if in.Configurator != nil {
		in, out := &in.Configurator, &out.Configurator
		*out = new(Configurator)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtraInitContainers != nil {
		in, out := &in.ExtraInitContainers, &out.ExtraInitContainers
		*out = new(string)
		**out = **in
	}
	if in.SetDataDirOwnership != nil {
		in, out := &in.SetDataDirOwnership, &out.SetDataDirOwnership
		*out = new(SetDataDirOwnership)
		(*in).DeepCopyInto(*out)
	}
	if in.SetTieredStorageCacheDirOwnership != nil {
		in, out := &in.SetTieredStorageCacheDirOwnership, &out.SetTieredStorageCacheDirOwnership
		*out = new(SetTieredStorageCacheDirOwnership)
		(*in).DeepCopyInto(*out)
	}
	if in.FsValidator != nil {
		in, out := &in.FsValidator, &out.FsValidator
		*out = new(FsValidator)
		(*in).DeepCopyInto(*out)
	}
	if in.Tuning != nil {
		in, out := &in.Tuning, &out.Tuning
		*out = new(Tuning)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InitContainers.
func (in *InitContainers) DeepCopy() *InitContainers {
	if in == nil {
		return nil
	}
	out := new(InitContainers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IssuerRef) DeepCopyInto(out *IssuerRef) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IssuerRef.
func (in *IssuerRef) DeepCopy() *IssuerRef {
	if in == nil {
		return nil
	}
	out := new(IssuerRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	if in.AuthenticationMethod != nil {
		in, out := &in.AuthenticationMethod, &out.AuthenticationMethod
		*out = new(string)
		**out = **in
	}
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = make(map[string]*ExternalListener, len(*in))
		for key, val := range *in {
			var outVal *ExternalListener
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(ExternalListener)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.PrefixTemplate != nil {
		in, out := &in.PrefixTemplate, &out.PrefixTemplate
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAPISpec) DeepCopyInto(out *KafkaAPISpec) {
	*out = *in
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(CommonTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.SASL != nil {
		in, out := &in.SASL, &out.SASL
		*out = new(KafkaSASL)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAPISpec.
func (in *KafkaAPISpec) DeepCopy() *KafkaAPISpec {
	if in == nil {
		return nil
	}
	out := new(KafkaAPISpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASL) DeepCopyInto(out *KafkaSASL) {
	*out = *in
	out.Password = in.Password
	out.OAUth = in.OAUth
	out.GSSAPIConfig = in.GSSAPIConfig
	out.AWSMskIam = in.AWSMskIam
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASL.
func (in *KafkaSASL) DeepCopy() *KafkaSASL {
	if in == nil {
		return nil
	}
	out := new(KafkaSASL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLAWSMskIam) DeepCopyInto(out *KafkaSASLAWSMskIam) {
	*out = *in
	out.SecretKey = in.SecretKey
	out.SessionToken = in.SessionToken
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLAWSMskIam.
func (in *KafkaSASLAWSMskIam) DeepCopy() *KafkaSASLAWSMskIam {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLAWSMskIam)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLGSSAPI) DeepCopyInto(out *KafkaSASLGSSAPI) {
	*out = *in
	out.Password = in.Password
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLGSSAPI.
func (in *KafkaSASLGSSAPI) DeepCopy() *KafkaSASLGSSAPI {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLGSSAPI)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSASLOAuthBearer) DeepCopyInto(out *KafkaSASLOAuthBearer) {
	*out = *in
	out.Token = in.Token
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSASLOAuthBearer.
func (in *KafkaSASLOAuthBearer) DeepCopy() *KafkaSASLOAuthBearer {
	if in == nil {
		return nil
	}
	out := new(KafkaSASLOAuthBearer)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LicenseSecretRef) DeepCopyInto(out *LicenseSecretRef) {
	*out = *in
	if in.SecretKey != nil {
		in, out := &in.SecretKey, &out.SecretKey
		*out = new(string)
		**out = **in
	}
	if in.SecretName != nil {
		in, out := &in.SecretName, &out.SecretName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LicenseSecretRef.
func (in *LicenseSecretRef) DeepCopy() *LicenseSecretRef {
	if in == nil {
		return nil
	}
	out := new(LicenseSecretRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ListenerTLS) DeepCopyInto(out *ListenerTLS) {
	*out = *in
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.SecretRef != nil {
		in, out := &in.SecretRef, &out.SecretRef
		*out = new(string)
		**out = **in
	}
	if in.RequireClientAuth != nil {
		in, out := &in.RequireClientAuth, &out.RequireClientAuth
		*out = new(bool)
		**out = **in
	}
	if in.TrustStore != nil {
		in, out := &in.TrustStore, &out.TrustStore
		*out = new(TrustStore)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ListenerTLS.
func (in *ListenerTLS) DeepCopy() *ListenerTLS {
	if in == nil {
		return nil
	}
	out := new(ListenerTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Listeners) DeepCopyInto(out *Listeners) {
	*out = *in
	if in.Admin != nil {
		in, out := &in.Admin, &out.Admin
		*out = new(Admin)
		(*in).DeepCopyInto(*out)
	}
	if in.HTTP != nil {
		in, out := &in.HTTP, &out.HTTP
		*out = new(HTTP)
		(*in).DeepCopyInto(*out)
	}
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = new(Kafka)
		(*in).DeepCopyInto(*out)
	}
	if in.RPC != nil {
		in, out := &in.RPC, &out.RPC
		*out = new(RPC)
		(*in).DeepCopyInto(*out)
	}
	if in.SchemaRegistry != nil {
		in, out := &in.SchemaRegistry, &out.SchemaRegistry
		*out = new(SchemaRegistry)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Listeners.
func (in *Listeners) DeepCopy() *Listeners {
	if in == nil {
		return nil
	}
	out := new(Listeners)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LivenessProbe) DeepCopyInto(out *LivenessProbe) {
	*out = *in
	if in.FailureThreshold != nil {
		in, out := &in.FailureThreshold, &out.FailureThreshold
		*out = new(int)
		**out = **in
	}
	if in.InitialDelaySeconds != nil {
		in, out := &in.InitialDelaySeconds, &out.InitialDelaySeconds
		*out = new(int)
		**out = **in
	}
	if in.PeriodSeconds != nil {
		in, out := &in.PeriodSeconds, &out.PeriodSeconds
		*out = new(int)
		**out = **in
	}
	if in.TimeoutSeconds != nil {
		in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
		*out = new(int)
		**out = **in
	}
	if in.SuccessThreshold != nil {
		in, out := &in.SuccessThreshold, &out.SuccessThreshold
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LivenessProbe.
func (in *LivenessProbe) DeepCopy() *LivenessProbe {
	if in == nil {
		return nil
	}
	out := new(LivenessProbe)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Logging) DeepCopyInto(out *Logging) {
	*out = *in
	if in.LogLevel != nil {
		in, out := &in.LogLevel, &out.LogLevel
		*out = new(string)
		**out = **in
	}
	if in.UsageStats != nil {
		in, out := &in.UsageStats, &out.UsageStats
		*out = new(UsageStats)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Logging.
func (in *Logging) DeepCopy() *Logging {
	if in == nil {
		return nil
	}
	out := new(Logging)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Memory) DeepCopyInto(out *Memory) {
	*out = *in
	if in.Container != nil {
		in, out := &in.Container, &out.Container
		*out = new(ContainerResources)
		(*in).DeepCopyInto(*out)
	}
	if in.EnableMemoryLocking != nil {
		in, out := &in.EnableMemoryLocking, &out.EnableMemoryLocking
		*out = new(bool)
		**out = **in
	}
	if in.Redpanda != nil {
		in, out := &in.Redpanda, &out.Redpanda
		*out = new(RedpandaMemory)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Memory.
func (in *Memory) DeepCopy() *Memory {
	if in == nil {
		return nil
	}
	out := new(Memory)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MetadataTemplate) DeepCopyInto(out *MetadataTemplate) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MetadataTemplate.
func (in *MetadataTemplate) DeepCopy() *MetadataTemplate {
	if in == nil {
		return nil
	}
	out := new(MetadataTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Migration) DeepCopyInto(out *Migration) {
	*out = *in
	out.ClusterRef = in.ClusterRef
	out.ConsoleRef = in.ConsoleRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Migration.
func (in *Migration) DeepCopy() *Migration {
	if in == nil {
		return nil
	}
	out := new(Migration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Monitoring) DeepCopyInto(out *Monitoring) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScrapeInterval != nil {
		in, out := &in.ScrapeInterval, &out.ScrapeInterval
		*out = new(string)
		**out = **in
	}
	if in.TLSConfig != nil {
		in, out := &in.TLSConfig, &out.TLSConfig
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.EnableHTTP2 != nil {
		in, out := &in.EnableHTTP2, &out.EnableHTTP2
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Monitoring.
func (in *Monitoring) DeepCopy() *Monitoring {
	if in == nil {
		return nil
	}
	out := new(Monitoring)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Password) DeepCopyInto(out *Password) {
	*out = *in
	if in.ValueFrom != nil {
		in, out := &in.ValueFrom, &out.ValueFrom
		*out = new(PasswordSource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Password.
func (in *Password) DeepCopy() *Password {
	if in == nil {
		return nil
	}
	out := new(Password)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PasswordSource) DeepCopyInto(out *PasswordSource) {
	*out = *in
	if in.SecretKeyRef != nil {
		in, out := &in.SecretKeyRef, &out.SecretKeyRef
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PasswordSource.
func (in *PasswordSource) DeepCopy() *PasswordSource {
	if in == nil {
		return nil
	}
	out := new(PasswordSource)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PersistentVolume) DeepCopyInto(out *PersistentVolume) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.StorageClass != nil {
		in, out := &in.StorageClass, &out.StorageClass
		*out = new(string)
		**out = **in
	}
	if in.NameOverwrite != nil {
		in, out := &in.NameOverwrite, &out.NameOverwrite
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PersistentVolume.
func (in *PersistentVolume) DeepCopy() *PersistentVolume {
	if in == nil {
		return nil
	}
	out := new(PersistentVolume)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PodAntiAffinity) DeepCopyInto(out *PodAntiAffinity) {
	*out = *in
	if in.TopologyKey != nil {
		in, out := &in.TopologyKey, &out.TopologyKey
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(int)
		**out = **in
	}
	if in.Custom != nil {
		in, out := &in.Custom, &out.Custom
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PodAntiAffinity.
func (in *PodAntiAffinity) DeepCopy() *PodAntiAffinity {
	if in == nil {
		return nil
	}
	out := new(PodAntiAffinity)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PodSpec) DeepCopyInto(out *PodSpec) {
	*out = *in
	if in.Containers != nil {
		in, out := &in.Containers, &out.Containers
		*out = make([]Container, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.PodSecurityContext)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PodSpec.
func (in *PodSpec) DeepCopy() *PodSpec {
	if in == nil {
		return nil
	}
	out := new(PodSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PodTemplate) DeepCopyInto(out *PodTemplate) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Spec != nil {
		in, out := &in.Spec, &out.Spec
		*out = new(PodSpec)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PodTemplate.
func (in *PodTemplate) DeepCopy() *PodTemplate {
	if in == nil {
		return nil
	}
	out := new(PodTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostInstallJob) DeepCopyInto(out *PostInstallJob) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.PodTemplate != nil {
		in, out := &in.PodTemplate, &out.PodTemplate
		*out = new(PodTemplate)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostInstallJob.
func (in *PostInstallJob) DeepCopy() *PostInstallJob {
	if in == nil {
		return nil
	}
	out := new(PostInstallJob)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostUpgradeJob) DeepCopyInto(out *PostUpgradeJob) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ExtraEnv != nil {
		in, out := &in.ExtraEnv, &out.ExtraEnv
		*out = make([]v1.EnvVar, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExtraEnvFrom != nil {
		in, out := &in.ExtraEnvFrom, &out.ExtraEnvFrom
		*out = make([]v1.EnvFromSource, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.BackoffLimit != nil {
		in, out := &in.BackoffLimit, &out.BackoffLimit
		*out = new(int32)
		**out = **in
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.PodTemplate != nil {
		in, out := &in.PodTemplate, &out.PodTemplate
		*out = new(PodTemplate)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostUpgradeJob.
func (in *PostUpgradeJob) DeepCopy() *PostUpgradeJob {
	if in == nil {
		return nil
	}
	out := new(PostUpgradeJob)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RBAC) DeepCopyInto(out *RBAC) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RBAC.
func (in *RBAC) DeepCopy() *RBAC {
	if in == nil {
		return nil
	}
	out := new(RBAC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPC) DeepCopyInto(out *RPC) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPC.
func (in *RPC) DeepCopy() *RPC {
	if in == nil {
		return nil
	}
	out := new(RPC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPControllers) DeepCopyInto(out *RPControllers) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(RedpandaImage)
		(*in).DeepCopyInto(*out)
	}
	if in.HealthProbeAddress != nil {
		in, out := &in.HealthProbeAddress, &out.HealthProbeAddress
		*out = new(string)
		**out = **in
	}
	if in.MetricsAddress != nil {
		in, out := &in.MetricsAddress, &out.MetricsAddress
		*out = new(string)
		**out = **in
	}
	if in.Run != nil {
		in, out := &in.Run, &out.Run
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.CreateRBAC != nil {
		in, out := &in.CreateRBAC, &out.CreateRBAC
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPControllers.
func (in *RPControllers) DeepCopy() *RPControllers {
	if in == nil {
		return nil
	}
	out := new(RPControllers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RackAwareness) DeepCopyInto(out *RackAwareness) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.NodeAnnotation != nil {
		in, out := &in.NodeAnnotation, &out.NodeAnnotation
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RackAwareness.
func (in *RackAwareness) DeepCopy() *RackAwareness {
	if in == nil {
		return nil
	}
	out := new(RackAwareness)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReadinessProbe) DeepCopyInto(out *ReadinessProbe) {
	*out = *in
	if in.FailureThreshold != nil {
		in, out := &in.FailureThreshold, &out.FailureThreshold
		*out = new(int)
		**out = **in
	}
	if in.InitialDelaySeconds != nil {
		in, out := &in.InitialDelaySeconds, &out.InitialDelaySeconds
		*out = new(int)
		**out = **in
	}
	if in.PeriodSeconds != nil {
		in, out := &in.PeriodSeconds, &out.PeriodSeconds
		*out = new(int)
		**out = **in
	}
	if in.TimeoutSeconds != nil {
		in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
		*out = new(int)
		**out = **in
	}
	if in.SuccessThreshold != nil {
		in, out := &in.SuccessThreshold, &out.SuccessThreshold
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReadinessProbe.
func (in *ReadinessProbe) DeepCopy() *ReadinessProbe {
	if in == nil {
		return nil
	}
	out := new(ReadinessProbe)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Redpanda) DeepCopyInto(out *Redpanda) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Redpanda.
func (in *Redpanda) DeepCopy() *Redpanda {
	if in == nil {
		return nil
	}
	out := new(Redpanda)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Redpanda) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaClusterSpec) DeepCopyInto(out *RedpandaClusterSpec) {
	*out = *in
	if in.NameOverride != nil {
		in, out := &in.NameOverride, &out.NameOverride
		*out = new(string)
		**out = **in
	}
	if in.FullnameOverride != nil {
		in, out := &in.FullnameOverride, &out.FullnameOverride
		*out = new(string)
		**out = **in
	}
	if in.ClusterDomain != nil {
		in, out := &in.ClusterDomain, &out.ClusterDomain
		*out = new(string)
		**out = **in
	}
	if in.CommonLabels != nil {
		in, out := &in.CommonLabels, &out.CommonLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NodeSelector != nil {
		in, out := &in.NodeSelector, &out.NodeSelector
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(RedpandaImage)
		(*in).DeepCopyInto(*out)
	}
	if in.ImagePullSecrets != nil {
		in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]v1.LocalObjectReference, len(*in))
		copy(*out, *in)
	}
	if in.LicenseKey != nil {
		in, out := &in.LicenseKey, &out.LicenseKey
		*out = new(string)
		**out = **in
	}
	if in.LicenseSecretRef != nil {
		in, out := &in.LicenseSecretRef, &out.LicenseSecretRef
		*out = new(LicenseSecretRef)
		(*in).DeepCopyInto(*out)
	}
	if in.Enterprise != nil {
		in, out := &in.Enterprise, &out.Enterprise
		*out = new(Enterprise)
		(*in).DeepCopyInto(*out)
	}
	if in.RackAwareness != nil {
		in, out := &in.RackAwareness, &out.RackAwareness
		*out = new(RackAwareness)
		(*in).DeepCopyInto(*out)
	}
	if in.Console != nil {
		in, out := &in.Console, &out.Console
		*out = new(RedpandaConsole)
		(*in).DeepCopyInto(*out)
	}
	if in.Connectors != nil {
		in, out := &in.Connectors, &out.Connectors
		*out = new(RedpandaConnectors)
		(*in).DeepCopyInto(*out)
	}
	if in.Auth != nil {
		in, out := &in.Auth, &out.Auth
		*out = new(Auth)
		(*in).DeepCopyInto(*out)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(TLS)
		(*in).DeepCopyInto(*out)
	}
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = new(External)
		(*in).DeepCopyInto(*out)
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = new(Logging)
		(*in).DeepCopyInto(*out)
	}
	if in.AuditLogging != nil {
		in, out := &in.AuditLogging, &out.AuditLogging
		*out = new(AuditLogging)
		(*in).DeepCopyInto(*out)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(Resources)
		(*in).DeepCopyInto(*out)
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(Service)
		(*in).DeepCopyInto(*out)
	}
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = new(Storage)
		(*in).DeepCopyInto(*out)
	}
	if in.PostInstallJob != nil {
		in, out := &in.PostInstallJob, &out.PostInstallJob
		*out = new(PostInstallJob)
		(*in).DeepCopyInto(*out)
	}
	if in.PostUpgradeJob != nil {
		in, out := &in.PostUpgradeJob, &out.PostUpgradeJob
		*out = new(PostUpgradeJob)
		(*in).DeepCopyInto(*out)
	}
	if in.Statefulset != nil {
		in, out := &in.Statefulset, &out.Statefulset
		*out = new(Statefulset)
		(*in).DeepCopyInto(*out)
	}
	if in.Tuning != nil {
		in, out := &in.Tuning, &out.Tuning
		*out = new(Tuning)
		(*in).DeepCopyInto(*out)
	}
	if in.Listeners != nil {
		in, out := &in.Listeners, &out.Listeners
		*out = new(Listeners)
		(*in).DeepCopyInto(*out)
	}
	if in.Config != nil {
		in, out := &in.Config, &out.Config
		*out = new(Config)
		(*in).DeepCopyInto(*out)
	}
	if in.RBAC != nil {
		in, out := &in.RBAC, &out.RBAC
		*out = new(RBAC)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccount != nil {
		in, out := &in.ServiceAccount, &out.ServiceAccount
		*out = new(ServiceAccount)
		(*in).DeepCopyInto(*out)
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = new(Monitoring)
		(*in).DeepCopyInto(*out)
	}
	if in.Force != nil {
		in, out := &in.Force, &out.Force
		*out = new(bool)
		**out = **in
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Tests != nil {
		in, out := &in.Tests, &out.Tests
		*out = new(Enablable)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaClusterSpec.
func (in *RedpandaClusterSpec) DeepCopy() *RedpandaClusterSpec {
	if in == nil {
		return nil
	}
	out := new(RedpandaClusterSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaConnectors) DeepCopyInto(out *RedpandaConnectors) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Test != nil {
		in, out := &in.Test, &out.Test
		*out = new(ConnectorsCreateObj)
		(*in).DeepCopyInto(*out)
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = new(ConnectorMonitoring)
		(*in).DeepCopyInto(*out)
	}
	if in.Connectors != nil {
		in, out := &in.Connectors, &out.Connectors
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Deployment != nil {
		in, out := &in.Deployment, &out.Deployment
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.NameOverride != nil {
		in, out := &in.NameOverride, &out.NameOverride
		*out = new(string)
		**out = **in
	}
	if in.FullNameOverride != nil {
		in, out := &in.FullNameOverride, &out.FullNameOverride
		*out = new(string)
		**out = **in
	}
	if in.CommonLabels != nil {
		in, out := &in.CommonLabels, &out.CommonLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(RedpandaImage)
		(*in).DeepCopyInto(*out)
	}
	if in.ImagePullSecrets != nil {
		in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]v1.LocalObjectReference, len(*in))
		copy(*out, *in)
	}
	if in.Auth != nil {
		in, out := &in.Auth, &out.Auth
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Container != nil {
		in, out := &in.Container, &out.Container
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccount != nil {
		in, out := &in.ServiceAccount, &out.ServiceAccount
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaConnectors.
func (in *RedpandaConnectors) DeepCopy() *RedpandaConnectors {
	if in == nil {
		return nil
	}
	out := new(RedpandaConnectors)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaConsole) DeepCopyInto(out *RedpandaConsole) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicaCount != nil {
		in, out := &in.ReplicaCount, &out.ReplicaCount
		*out = new(int)
		**out = **in
	}
	if in.NameOverride != nil {
		in, out := &in.NameOverride, &out.NameOverride
		*out = new(string)
		**out = **in
	}
	if in.FullNameOverride != nil {
		in, out := &in.FullNameOverride, &out.FullNameOverride
		*out = new(string)
		**out = **in
	}
	if in.CommonLabels != nil {
		in, out := &in.CommonLabels, &out.CommonLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PriorityClassName != nil {
		in, out := &in.PriorityClassName, &out.PriorityClassName
		*out = new(string)
		**out = **in
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.ImagePullSecrets != nil {
		in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.ServiceAccount != nil {
		in, out := &in.ServiceAccount, &out.ServiceAccount
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.PodAnnotations != nil {
		in, out := &in.PodAnnotations, &out.PodAnnotations
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.PodLabels != nil {
		in, out := &in.PodLabels, &out.PodLabels
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.PodSecurityContext != nil {
		in, out := &in.PodSecurityContext, &out.PodSecurityContext
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Ingress != nil {
		in, out := &in.Ingress, &out.Ingress
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Autoscaling != nil {
		in, out := &in.Autoscaling, &out.Autoscaling
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.NodeSelector != nil {
		in, out := &in.NodeSelector, &out.NodeSelector
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.TopologySpreadConstraints != nil {
		in, out := &in.TopologySpreadConstraints, &out.TopologySpreadConstraints
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtraEnv != nil {
		in, out := &in.ExtraEnv, &out.ExtraEnv
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.ExtraEnvFrom != nil {
		in, out := &in.ExtraEnvFrom, &out.ExtraEnvFrom
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.ExtraVolumes != nil {
		in, out := &in.ExtraVolumes, &out.ExtraVolumes
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.ExtraContainers != nil {
		in, out := &in.ExtraContainers, &out.ExtraContainers
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.InitContainers != nil {
		in, out := &in.InitContainers, &out.InitContainers
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretMounts != nil {
		in, out := &in.SecretMounts, &out.SecretMounts
		*out = make([]*runtime.RawExtension, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(runtime.RawExtension)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.DeprecatedConfigMap != nil {
		in, out := &in.DeprecatedConfigMap, &out.DeprecatedConfigMap
		*out = new(ConsoleCreateObj)
		(*in).DeepCopyInto(*out)
	}
	if in.ConfigMap != nil {
		in, out := &in.ConfigMap, &out.ConfigMap
		*out = new(ConsoleCreateObj)
		(*in).DeepCopyInto(*out)
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Deployment != nil {
		in, out := &in.Deployment, &out.Deployment
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Console != nil {
		in, out := &in.Console, &out.Console
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Strategy != nil {
		in, out := &in.Strategy, &out.Strategy
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.Enterprise != nil {
		in, out := &in.Enterprise, &out.Enterprise
		*out = new(runtime.RawExtension)
		(*in).DeepCopyInto(*out)
	}
	if in.AutomountServiceAccountToken != nil {
		in, out := &in.AutomountServiceAccountToken, &out.AutomountServiceAccountToken
		*out = new(bool)
		**out = **in
	}
	if in.ReadinessProbe != nil {
		in, out := &in.ReadinessProbe, &out.ReadinessProbe
		*out = new(ReadinessProbe)
		(*in).DeepCopyInto(*out)
	}
	if in.LivenessProbe != nil {
		in, out := &in.LivenessProbe, &out.LivenessProbe
		*out = new(LivenessProbe)
		(*in).DeepCopyInto(*out)
	}
	if in.Tests != nil {
		in, out := &in.Tests, &out.Tests
		*out = new(Enablable)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaConsole.
func (in *RedpandaConsole) DeepCopy() *RedpandaConsole {
	if in == nil {
		return nil
	}
	out := new(RedpandaConsole)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaImage) DeepCopyInto(out *RedpandaImage) {
	*out = *in
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(string)
		**out = **in
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
	if in.PullPolicy != nil {
		in, out := &in.PullPolicy, &out.PullPolicy
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaImage.
func (in *RedpandaImage) DeepCopy() *RedpandaImage {
	if in == nil {
		return nil
	}
	out := new(RedpandaImage)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaList) DeepCopyInto(out *RedpandaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Redpanda, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaList.
func (in *RedpandaList) DeepCopy() *RedpandaList {
	if in == nil {
		return nil
	}
	out := new(RedpandaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RedpandaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaMemory) DeepCopyInto(out *RedpandaMemory) {
	*out = *in
	if in.Memory != nil {
		in, out := &in.Memory, &out.Memory
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.ReserveMemory != nil {
		in, out := &in.ReserveMemory, &out.ReserveMemory
		x := (*in).DeepCopy()
		*out = &x
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaMemory.
func (in *RedpandaMemory) DeepCopy() *RedpandaMemory {
	if in == nil {
		return nil
	}
	out := new(RedpandaMemory)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaSpec) DeepCopyInto(out *RedpandaSpec) {
	*out = *in
	in.ChartRef.DeepCopyInto(&out.ChartRef)
	if in.ClusterSpec != nil {
		in, out := &in.ClusterSpec, &out.ClusterSpec
		*out = new(RedpandaClusterSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Migration != nil {
		in, out := &in.Migration, &out.Migration
		*out = new(Migration)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaSpec.
func (in *RedpandaSpec) DeepCopy() *RedpandaSpec {
	if in == nil {
		return nil
	}
	out := new(RedpandaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedpandaStatus) DeepCopyInto(out *RedpandaStatus) {
	*out = *in
	out.ReconcileRequestStatus = in.ReconcileRequestStatus
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HelmReleaseReady != nil {
		in, out := &in.HelmReleaseReady, &out.HelmReleaseReady
		*out = new(bool)
		**out = **in
	}
	if in.HelmRepositoryReady != nil {
		in, out := &in.HelmRepositoryReady, &out.HelmRepositoryReady
		*out = new(bool)
		**out = **in
	}
	if in.ManagedDecommissioningNode != nil {
		in, out := &in.ManagedDecommissioningNode, &out.ManagedDecommissioningNode
		*out = new(int32)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedpandaStatus.
func (in *RedpandaStatus) DeepCopy() *RedpandaStatus {
	if in == nil {
		return nil
	}
	out := new(RedpandaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceTemplate) DeepCopyInto(out *ResourceTemplate) {
	*out = *in
	in.Metadata.DeepCopyInto(&out.Metadata)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceTemplate.
func (in *ResourceTemplate) DeepCopy() *ResourceTemplate {
	if in == nil {
		return nil
	}
	out := new(ResourceTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Resources) DeepCopyInto(out *Resources) {
	*out = *in
	if in.CPU != nil {
		in, out := &in.CPU, &out.CPU
		*out = new(CPU)
		(*in).DeepCopyInto(*out)
	}
	if in.Memory != nil {
		in, out := &in.Memory, &out.Memory
		*out = new(Memory)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Resources.
func (in *Resources) DeepCopy() *Resources {
	if in == nil {
		return nil
	}
	out := new(Resources)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SASL) DeepCopyInto(out *SASL) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Mechanism != nil {
		in, out := &in.Mechanism, &out.Mechanism
		*out = new(string)
		**out = **in
	}
	if in.SecretRef != nil {
		in, out := &in.SecretRef, &out.SecretRef
		*out = new(string)
		**out = **in
	}
	if in.Users != nil {
		in, out := &in.Users, &out.Users
		*out = make([]UsersItems, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.BootstrapUser != nil {
		in, out := &in.BootstrapUser, &out.BootstrapUser
		*out = new(BootstrapUser)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SASL.
func (in *SASL) DeepCopy() *SASL {
	if in == nil {
		return nil
	}
	out := new(SASL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SchemaRegistry) DeepCopyInto(out *SchemaRegistry) {
	*out = *in
	if in.AuthenticationMethod != nil {
		in, out := &in.AuthenticationMethod, &out.AuthenticationMethod
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = make(map[string]*ExternalListener, len(*in))
		for key, val := range *in {
			var outVal *ExternalListener
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(ExternalListener)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.KafkaEndpoint != nil {
		in, out := &in.KafkaEndpoint, &out.KafkaEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(ListenerTLS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SchemaRegistry.
func (in *SchemaRegistry) DeepCopy() *SchemaRegistry {
	if in == nil {
		return nil
	}
	out := new(SchemaRegistry)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretKeyRef) DeepCopyInto(out *SecretKeyRef) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretKeyRef.
func (in *SecretKeyRef) DeepCopy() *SecretKeyRef {
	if in == nil {
		return nil
	}
	out := new(SecretKeyRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretRef) DeepCopyInto(out *SecretRef) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretRef.
func (in *SecretRef) DeepCopy() *SecretRef {
	if in == nil {
		return nil
	}
	out := new(SecretRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretWithConfigField) DeepCopyInto(out *SecretWithConfigField) {
	*out = *in
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.ConfigurationKey != nil {
		in, out := &in.ConfigurationKey, &out.ConfigurationKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretWithConfigField.
func (in *SecretWithConfigField) DeepCopy() *SecretWithConfigField {
	if in == nil {
		return nil
	}
	out := new(SecretWithConfigField)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Service) DeepCopyInto(out *Service) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Internal != nil {
		in, out := &in.Internal, &out.Internal
		*out = new(ServiceInternal)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Service.
func (in *Service) DeepCopy() *Service {
	if in == nil {
		return nil
	}
	out := new(Service)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceAccount) DeepCopyInto(out *ServiceAccount) {
	*out = *in
	if in.AutomountServiceAccountToken != nil {
		in, out := &in.AutomountServiceAccountToken, &out.AutomountServiceAccountToken
		*out = new(bool)
		**out = **in
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Create != nil {
		in, out := &in.Create, &out.Create
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceAccount.
func (in *ServiceAccount) DeepCopy() *ServiceAccount {
	if in == nil {
		return nil
	}
	out := new(ServiceAccount)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceInternal) DeepCopyInto(out *ServiceInternal) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceInternal.
func (in *ServiceInternal) DeepCopy() *ServiceInternal {
	if in == nil {
		return nil
	}
	out := new(ServiceInternal)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SetDataDirOwnership) DeepCopyInto(out *SetDataDirOwnership) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SetDataDirOwnership.
func (in *SetDataDirOwnership) DeepCopy() *SetDataDirOwnership {
	if in == nil {
		return nil
	}
	out := new(SetDataDirOwnership)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SetTieredStorageCacheDirOwnership) DeepCopyInto(out *SetTieredStorageCacheDirOwnership) {
	*out = *in
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SetTieredStorageCacheDirOwnership.
func (in *SetTieredStorageCacheDirOwnership) DeepCopy() *SetTieredStorageCacheDirOwnership {
	if in == nil {
		return nil
	}
	out := new(SetTieredStorageCacheDirOwnership)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SideCarObj) DeepCopyInto(out *SideCarObj) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SideCarObj.
func (in *SideCarObj) DeepCopy() *SideCarObj {
	if in == nil {
		return nil
	}
	out := new(SideCarObj)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SideCars) DeepCopyInto(out *SideCars) {
	*out = *in
	if in.ConfigWatcher != nil {
		in, out := &in.ConfigWatcher, &out.ConfigWatcher
		*out = new(ConfigWatcher)
		(*in).DeepCopyInto(*out)
	}
	if in.RpkStatus != nil {
		in, out := &in.RpkStatus, &out.RpkStatus
		*out = new(SideCarObj)
		(*in).DeepCopyInto(*out)
	}
	if in.Controllers != nil {
		in, out := &in.Controllers, &out.Controllers
		*out = new(RPControllers)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SideCars.
func (in *SideCars) DeepCopy() *SideCars {
	if in == nil {
		return nil
	}
	out := new(SideCars)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StartupProbe) DeepCopyInto(out *StartupProbe) {
	*out = *in
	if in.FailureThreshold != nil {
		in, out := &in.FailureThreshold, &out.FailureThreshold
		*out = new(int)
		**out = **in
	}
	if in.InitialDelaySeconds != nil {
		in, out := &in.InitialDelaySeconds, &out.InitialDelaySeconds
		*out = new(int)
		**out = **in
	}
	if in.PeriodSeconds != nil {
		in, out := &in.PeriodSeconds, &out.PeriodSeconds
		*out = new(int)
		**out = **in
	}
	if in.TimeoutSeconds != nil {
		in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
		*out = new(int)
		**out = **in
	}
	if in.SuccessThreshold != nil {
		in, out := &in.SuccessThreshold, &out.SuccessThreshold
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StartupProbe.
func (in *StartupProbe) DeepCopy() *StartupProbe {
	if in == nil {
		return nil
	}
	out := new(StartupProbe)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Statefulset) DeepCopyInto(out *Statefulset) {
	*out = *in
	if in.AdditionalSelectorsLabels != nil {
		in, out := &in.AdditionalSelectorsLabels, &out.AdditionalSelectorsLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.AdditionalRedpandaCmdFlags != nil {
		in, out := &in.AdditionalRedpandaCmdFlags, &out.AdditionalRedpandaCmdFlags
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PodTemplate != nil {
		in, out := &in.PodTemplate, &out.PodTemplate
		*out = new(PodTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.Budget != nil {
		in, out := &in.Budget, &out.Budget
		*out = new(Budget)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.ExtraVolumes != nil {
		in, out := &in.ExtraVolumes, &out.ExtraVolumes
		*out = new(string)
		**out = **in
	}
	if in.InitContainerImage != nil {
		in, out := &in.InitContainerImage, &out.InitContainerImage
		*out = new(InitContainerImage)
		(*in).DeepCopyInto(*out)
	}
	if in.InitContainers != nil {
		in, out := &in.InitContainers, &out.InitContainers
		*out = new(InitContainers)
		(*in).DeepCopyInto(*out)
	}
	if in.LivenessProbe != nil {
		in, out := &in.LivenessProbe, &out.LivenessProbe
		*out = new(LivenessProbe)
		(*in).DeepCopyInto(*out)
	}
	if in.NodeSelector != nil {
		in, out := &in.NodeSelector, &out.NodeSelector
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PodAffinity != nil {
		in, out := &in.PodAffinity, &out.PodAffinity
		*out = new(v1.PodAffinity)
		(*in).DeepCopyInto(*out)
	}
	if in.PodAntiAffinity != nil {
		in, out := &in.PodAntiAffinity, &out.PodAntiAffinity
		*out = new(PodAntiAffinity)
		(*in).DeepCopyInto(*out)
	}
	if in.PriorityClassName != nil {
		in, out := &in.PriorityClassName, &out.PriorityClassName
		*out = new(string)
		**out = **in
	}
	if in.ReadinessProbe != nil {
		in, out := &in.ReadinessProbe, &out.ReadinessProbe
		*out = new(ReadinessProbe)
		(*in).DeepCopyInto(*out)
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(int)
		**out = **in
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.SideCars != nil {
		in, out := &in.SideCars, &out.SideCars
		*out = new(SideCars)
		(*in).DeepCopyInto(*out)
	}
	if in.SkipChown != nil {
		in, out := &in.SkipChown, &out.SkipChown
		*out = new(bool)
		**out = **in
	}
	if in.StartupProbe != nil {
		in, out := &in.StartupProbe, &out.StartupProbe
		*out = new(StartupProbe)
		(*in).DeepCopyInto(*out)
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TopologySpreadConstraints != nil {
		in, out := &in.TopologySpreadConstraints, &out.TopologySpreadConstraints
		*out = make([]*TopologySpreadConstraints, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(TopologySpreadConstraints)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.UpdateStrategy != nil {
		in, out := &in.UpdateStrategy, &out.UpdateStrategy
		*out = new(UpdateStrategy)
		(*in).DeepCopyInto(*out)
	}
	if in.TerminationGracePeriodSeconds != nil {
		in, out := &in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Statefulset.
func (in *Statefulset) DeepCopy() *Statefulset {
	if in == nil {
		return nil
	}
	out := new(Statefulset)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StaticConfigurationSource) DeepCopyInto(out *StaticConfigurationSource) {
	*out = *in
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = new(KafkaAPISpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Admin != nil {
		in, out := &in.Admin, &out.Admin
		*out = new(AdminAPISpec)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StaticConfigurationSource.
func (in *StaticConfigurationSource) DeepCopy() *StaticConfigurationSource {
	if in == nil {
		return nil
	}
	out := new(StaticConfigurationSource)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Storage) DeepCopyInto(out *Storage) {
	*out = *in
	if in.HostPath != nil {
		in, out := &in.HostPath, &out.HostPath
		*out = new(string)
		**out = **in
	}
	if in.PersistentVolume != nil {
		in, out := &in.PersistentVolume, &out.PersistentVolume
		*out = new(PersistentVolume)
		(*in).DeepCopyInto(*out)
	}
	if in.Tiered != nil {
		in, out := &in.Tiered, &out.Tiered
		*out = new(Tiered)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Storage.
func (in *Storage) DeepCopy() *Storage {
	if in == nil {
		return nil
	}
	out := new(Storage)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TLS) DeepCopyInto(out *TLS) {
	*out = *in
	if in.Certs != nil {
		in, out := &in.Certs, &out.Certs
		*out = make(map[string]*Certificate, len(*in))
		for key, val := range *in {
			var outVal *Certificate
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(Certificate)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TLS.
func (in *TLS) DeepCopy() *TLS {
	if in == nil {
		return nil
	}
	out := new(TLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Tiered) DeepCopyInto(out *Tiered) {
	*out = *in
	if in.MountType != nil {
		in, out := &in.MountType, &out.MountType
		*out = new(string)
		**out = **in
	}
	if in.HostPath != nil {
		in, out := &in.HostPath, &out.HostPath
		*out = new(string)
		**out = **in
	}
	if in.PersistentVolume != nil {
		in, out := &in.PersistentVolume, &out.PersistentVolume
		*out = new(PersistentVolume)
		(*in).DeepCopyInto(*out)
	}
	if in.Config != nil {
		in, out := &in.Config, &out.Config
		*out = new(TieredConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.CredentialsSecretRef != nil {
		in, out := &in.CredentialsSecretRef, &out.CredentialsSecretRef
		*out = new(CredentialSecretRef)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tiered.
func (in *Tiered) DeepCopy() *Tiered {
	if in == nil {
		return nil
	}
	out := new(Tiered)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TieredConfig) DeepCopyInto(out *TieredConfig) {
	*out = *in
	if in.CloudStorageEnabled != nil {
		in, out := &in.CloudStorageEnabled, &out.CloudStorageEnabled
		*out = new(apiutil.JSONBoolean)
		(*in).DeepCopyInto(*out)
	}
	if in.CloudStorageAPIEndpoint != nil {
		in, out := &in.CloudStorageAPIEndpoint, &out.CloudStorageAPIEndpoint
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAPIEndpointPort != nil {
		in, out := &in.CloudStorageAPIEndpointPort, &out.CloudStorageAPIEndpointPort
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageBucket != nil {
		in, out := &in.CloudStorageBucket, &out.CloudStorageBucket
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureContainer != nil {
		in, out := &in.CloudStorageAzureContainer, &out.CloudStorageAzureContainer
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureManagedIdentityID != nil {
		in, out := &in.CloudStorageAzureManagedIdentityID, &out.CloudStorageAzureManagedIdentityID
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureStorageAccount != nil {
		in, out := &in.CloudStorageAzureStorageAccount, &out.CloudStorageAzureStorageAccount
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureSharedKey != nil {
		in, out := &in.CloudStorageAzureSharedKey, &out.CloudStorageAzureSharedKey
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureADLSEndpoint != nil {
		in, out := &in.CloudStorageAzureADLSEndpoint, &out.CloudStorageAzureADLSEndpoint
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageAzureADLSPort != nil {
		in, out := &in.CloudStorageAzureADLSPort, &out.CloudStorageAzureADLSPort
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageCacheCheckInterval != nil {
		in, out := &in.CloudStorageCacheCheckInterval, &out.CloudStorageCacheCheckInterval
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageCacheDirectory != nil {
		in, out := &in.CloudStorageCacheDirectory, &out.CloudStorageCacheDirectory
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageCacheSize != nil {
		in, out := &in.CloudStorageCacheSize, &out.CloudStorageCacheSize
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageCredentialsSource != nil {
		in, out := &in.CloudStorageCredentialsSource, &out.CloudStorageCredentialsSource
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageDisableTLS != nil {
		in, out := &in.CloudStorageDisableTLS, &out.CloudStorageDisableTLS
		*out = new(bool)
		**out = **in
	}
	if in.CloudStorageEnableRemoteRead != nil {
		in, out := &in.CloudStorageEnableRemoteRead, &out.CloudStorageEnableRemoteRead
		*out = new(bool)
		**out = **in
	}
	if in.CloudStorageEnableRemoteWrite != nil {
		in, out := &in.CloudStorageEnableRemoteWrite, &out.CloudStorageEnableRemoteWrite
		*out = new(bool)
		**out = **in
	}
	if in.CloudStorageInitialBackoffMs != nil {
		in, out := &in.CloudStorageInitialBackoffMs, &out.CloudStorageInitialBackoffMs
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageManifestUploadTimeoutMs != nil {
		in, out := &in.CloudStorageManifestUploadTimeoutMs, &out.CloudStorageManifestUploadTimeoutMs
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageMaxConnectionIdleTimeMs != nil {
		in, out := &in.CloudStorageMaxConnectionIdleTimeMs, &out.CloudStorageMaxConnectionIdleTimeMs
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageMaxConnections != nil {
		in, out := &in.CloudStorageMaxConnections, &out.CloudStorageMaxConnections
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageReconciliationIntervalMs != nil {
		in, out := &in.CloudStorageReconciliationIntervalMs, &out.CloudStorageReconciliationIntervalMs
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageRegion != nil {
		in, out := &in.CloudStorageRegion, &out.CloudStorageRegion
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageSegmentMaxUploadIntervalSec != nil {
		in, out := &in.CloudStorageSegmentMaxUploadIntervalSec, &out.CloudStorageSegmentMaxUploadIntervalSec
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageSegmentUploadTimeoutMs != nil {
		in, out := &in.CloudStorageSegmentUploadTimeoutMs, &out.CloudStorageSegmentUploadTimeoutMs
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageTrustFile != nil {
		in, out := &in.CloudStorageTrustFile, &out.CloudStorageTrustFile
		*out = new(string)
		**out = **in
	}
	if in.CloudStorageUploadCtrlDCoeff != nil {
		in, out := &in.CloudStorageUploadCtrlDCoeff, &out.CloudStorageUploadCtrlDCoeff
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageUploadCtrlMaxShares != nil {
		in, out := &in.CloudStorageUploadCtrlMaxShares, &out.CloudStorageUploadCtrlMaxShares
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageUploadCtrlMinShares != nil {
		in, out := &in.CloudStorageUploadCtrlMinShares, &out.CloudStorageUploadCtrlMinShares
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageUploadCtrlPCoeff != nil {
		in, out := &in.CloudStorageUploadCtrlPCoeff, &out.CloudStorageUploadCtrlPCoeff
		*out = new(int)
		**out = **in
	}
	if in.CloudStorageUploadCtrlUpdateIntervalMs != nil {
		in, out := &in.CloudStorageUploadCtrlUpdateIntervalMs, &out.CloudStorageUploadCtrlUpdateIntervalMs
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TieredConfig.
func (in *TieredConfig) DeepCopy() *TieredConfig {
	if in == nil {
		return nil
	}
	out := new(TieredConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Topic) DeepCopyInto(out *Topic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Topic.
func (in *Topic) DeepCopy() *Topic {
	if in == nil {
		return nil
	}
	out := new(Topic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Topic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicList) DeepCopyInto(out *TopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Topic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicList.
func (in *TopicList) DeepCopy() *TopicList {
	if in == nil {
		return nil
	}
	out := new(TopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicSpec) DeepCopyInto(out *TopicSpec) {
	*out = *in
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(int)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(int)
		**out = **in
	}
	if in.OverwriteTopicName != nil {
		in, out := &in.OverwriteTopicName, &out.OverwriteTopicName
		*out = new(string)
		**out = **in
	}
	if in.AdditionalConfig != nil {
		in, out := &in.AdditionalConfig, &out.AdditionalConfig
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ClusterSource != nil {
		in, out := &in.ClusterSource, &out.ClusterSource
		*out = new(ClusterSource)
		(*in).DeepCopyInto(*out)
	}
	if in.KafkaAPISpec != nil {
		in, out := &in.KafkaAPISpec, &out.KafkaAPISpec
		*out = new(KafkaAPISpec)
		(*in).DeepCopyInto(*out)
	}
	if in.MetricsNamespace != nil {
		in, out := &in.MetricsNamespace, &out.MetricsNamespace
		*out = new(string)
		**out = **in
	}
	if in.SynchronizationInterval != nil {
		in, out := &in.SynchronizationInterval, &out.SynchronizationInterval
		*out = new(metav1.Duration)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicSpec.
func (in *TopicSpec) DeepCopy() *TopicSpec {
	if in == nil {
		return nil
	}
	out := new(TopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicStatus) DeepCopyInto(out *TopicStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TopicConfiguration != nil {
		in, out := &in.TopicConfiguration, &out.TopicConfiguration
		*out = make([]Configuration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicStatus.
func (in *TopicStatus) DeepCopy() *TopicStatus {
	if in == nil {
		return nil
	}
	out := new(TopicStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopologySpreadConstraints) DeepCopyInto(out *TopologySpreadConstraints) {
	*out = *in
	if in.MaxSkew != nil {
		in, out := &in.MaxSkew, &out.MaxSkew
		*out = new(int)
		**out = **in
	}
	if in.TopologyKey != nil {
		in, out := &in.TopologyKey, &out.TopologyKey
		*out = new(string)
		**out = **in
	}
	if in.WhenUnsatisfiable != nil {
		in, out := &in.WhenUnsatisfiable, &out.WhenUnsatisfiable
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopologySpreadConstraints.
func (in *TopologySpreadConstraints) DeepCopy() *TopologySpreadConstraints {
	if in == nil {
		return nil
	}
	out := new(TopologySpreadConstraints)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TrustStore) DeepCopyInto(out *TrustStore) {
	*out = *in
	if in.ConfigMapKeyRef != nil {
		in, out := &in.ConfigMapKeyRef, &out.ConfigMapKeyRef
		*out = new(v1.ConfigMapKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.SecretKeyRef != nil {
		in, out := &in.SecretKeyRef, &out.SecretKeyRef
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TrustStore.
func (in *TrustStore) DeepCopy() *TrustStore {
	if in == nil {
		return nil
	}
	out := new(TrustStore)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Tuning) DeepCopyInto(out *Tuning) {
	*out = *in
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = new(string)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.BallastFilePath != nil {
		in, out := &in.BallastFilePath, &out.BallastFilePath
		*out = new(string)
		**out = **in
	}
	if in.BallastFileSize != nil {
		in, out := &in.BallastFileSize, &out.BallastFileSize
		*out = new(string)
		**out = **in
	}
	if in.TuneAioEvents != nil {
		in, out := &in.TuneAioEvents, &out.TuneAioEvents
		*out = new(bool)
		**out = **in
	}
	if in.TuneBallastFile != nil {
		in, out := &in.TuneBallastFile, &out.TuneBallastFile
		*out = new(bool)
		**out = **in
	}
	if in.TuneClockSource != nil {
		in, out := &in.TuneClockSource, &out.TuneClockSource
		*out = new(bool)
		**out = **in
	}
	if in.WellKnownIo != nil {
		in, out := &in.WellKnownIo, &out.WellKnownIo
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tuning.
func (in *Tuning) DeepCopy() *Tuning {
	if in == nil {
		return nil
	}
	out := new(Tuning)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UpdateStrategy) DeepCopyInto(out *UpdateStrategy) {
	*out = *in
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UpdateStrategy.
func (in *UpdateStrategy) DeepCopy() *UpdateStrategy {
	if in == nil {
		return nil
	}
	out := new(UpdateStrategy)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UsageStats) DeepCopyInto(out *UsageStats) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Organization != nil {
		in, out := &in.Organization, &out.Organization
		*out = new(string)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UsageStats.
func (in *UsageStats) DeepCopy() *UsageStats {
	if in == nil {
		return nil
	}
	out := new(UsageStats)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *User) DeepCopyInto(out *User) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new User.
func (in *User) DeepCopy() *User {
	if in == nil {
		return nil
	}
	out := new(User)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *User) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAuthenticationSpec) DeepCopyInto(out *UserAuthenticationSpec) {
	*out = *in
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(SASLMechanism)
		**out = **in
	}
	in.Password.DeepCopyInto(&out.Password)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAuthenticationSpec.
func (in *UserAuthenticationSpec) DeepCopy() *UserAuthenticationSpec {
	if in == nil {
		return nil
	}
	out := new(UserAuthenticationSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAuthorizationSpec) DeepCopyInto(out *UserAuthorizationSpec) {
	*out = *in
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(AuthorizationType)
		**out = **in
	}
	if in.ACLs != nil {
		in, out := &in.ACLs, &out.ACLs
		*out = make([]ACLRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAuthorizationSpec.
func (in *UserAuthorizationSpec) DeepCopy() *UserAuthorizationSpec {
	if in == nil {
		return nil
	}
	out := new(UserAuthorizationSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserList) DeepCopyInto(out *UserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]User, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserList.
func (in *UserList) DeepCopy() *UserList {
	if in == nil {
		return nil
	}
	out := new(UserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *UserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserSpec) DeepCopyInto(out *UserSpec) {
	*out = *in
	if in.ClusterSource != nil {
		in, out := &in.ClusterSource, &out.ClusterSource
		*out = new(ClusterSource)
		(*in).DeepCopyInto(*out)
	}
	if in.Authentication != nil {
		in, out := &in.Authentication, &out.Authentication
		*out = new(UserAuthenticationSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Authorization != nil {
		in, out := &in.Authorization, &out.Authorization
		*out = new(UserAuthorizationSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Template != nil {
		in, out := &in.Template, &out.Template
		*out = new(UserTemplateSpec)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserSpec.
func (in *UserSpec) DeepCopy() *UserSpec {
	if in == nil {
		return nil
	}
	out := new(UserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserStatus) DeepCopyInto(out *UserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserStatus.
func (in *UserStatus) DeepCopy() *UserStatus {
	if in == nil {
		return nil
	}
	out := new(UserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserTemplateSpec) DeepCopyInto(out *UserTemplateSpec) {
	*out = *in
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(ResourceTemplate)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserTemplateSpec.
func (in *UserTemplateSpec) DeepCopy() *UserTemplateSpec {
	if in == nil {
		return nil
	}
	out := new(UserTemplateSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UsersItems) DeepCopyInto(out *UsersItems) {
	*out = *in
	if in.Mechanism != nil {
		in, out := &in.Mechanism, &out.Mechanism
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Password != nil {
		in, out := &in.Password, &out.Password
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UsersItems.
func (in *UsersItems) DeepCopy() *UsersItems {
	if in == nil {
		return nil
	}
	out := new(UsersItems)
	in.DeepCopyInto(out)
	return out
}
