// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package v1alpha2

import (
	v3 "github.com/redpanda-data/redpanda-operator/charts/console/v3"
	ir "github.com/redpanda-data/redpanda-operator/pkg/ir"
	v11 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	v13 "k8s.io/api/networking/v1"
	v12 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

func init() {
	ConvertConsoleToConsolePartialRenderValues = func(source *ConsoleValues) (*v3.PartialRenderValues, error) {
		var pConsolePartialRenderValues *v3.PartialRenderValues
		if source != nil {
			var consolePartialRenderValues v3.PartialRenderValues
			if (*source).ReplicaCount != nil {
				xint32 := *(*source).ReplicaCount
				consolePartialRenderValues.ReplicaCount = &xint32
			}
			if (*source).CommonLabels != nil {
				consolePartialRenderValues.CommonLabels = make(map[string]string, len((*source).CommonLabels))
				for key, value := range (*source).CommonLabels {
					consolePartialRenderValues.CommonLabels[key] = value
				}
			}
			consolePartialRenderValues.Image = pV1alpha2ImageToPConsolePartialImage((*source).Image)
			if (*source).ImagePullSecrets != nil {
				consolePartialRenderValues.ImagePullSecrets = make([]v1.LocalObjectReference, len((*source).ImagePullSecrets))
				for i := 0; i < len((*source).ImagePullSecrets); i++ {
					consolePartialRenderValues.ImagePullSecrets[i] = v1LocalObjectReferenceToV1LocalObjectReference((*source).ImagePullSecrets[i])
				}
			}
			if (*source).AutomountServiceAccountToken != nil {
				xbool := *(*source).AutomountServiceAccountToken
				consolePartialRenderValues.AutomountServiceAccountToken = &xbool
			}
			consolePartialRenderValues.ServiceAccount = autoconv_ServiceAccountConfig_To_console_PartialServiceAccountConfig((*source).ServiceAccount)
			if (*source).Annotations != nil {
				consolePartialRenderValues.Annotations = make(map[string]string, len((*source).Annotations))
				for key2, value2 := range (*source).Annotations {
					consolePartialRenderValues.Annotations[key2] = value2
				}
			}
			if (*source).PodAnnotations != nil {
				consolePartialRenderValues.PodAnnotations = make(map[string]string, len((*source).PodAnnotations))
				for key3, value3 := range (*source).PodAnnotations {
					consolePartialRenderValues.PodAnnotations[key3] = value3
				}
			}
			if (*source).PodLabels != nil {
				consolePartialRenderValues.PodLabels = make(map[string]string, len((*source).PodLabels))
				for key4, value4 := range (*source).PodLabels {
					consolePartialRenderValues.PodLabels[key4] = value4
				}
			}
			consolePartialRenderValues.PodSecurityContext = pV1PodSecurityContextToPV1PodSecurityContext((*source).PodSecurityContext)
			consolePartialRenderValues.SecurityContext = pV1SecurityContextToPV1SecurityContext((*source).SecurityContext)
			consolePartialRenderValues.Service = pV1alpha2ServiceConfigToPConsolePartialServiceConfig((*source).Service)
			consolePartialRenderValues.Ingress = pV1alpha2IngressConfigToPConsolePartialIngressConfig((*source).Ingress)
			consolePartialRenderValues.Resources = pV1ResourceRequirementsToPV1ResourceRequirements((*source).Resources)
			consolePartialRenderValues.Autoscaling = pV1alpha2AutoScalingToPConsolePartialAutoScaling((*source).Autoscaling)
			if (*source).NodeSelector != nil {
				consolePartialRenderValues.NodeSelector = make(map[string]string, len((*source).NodeSelector))
				for key5, value5 := range (*source).NodeSelector {
					consolePartialRenderValues.NodeSelector[key5] = value5
				}
			}
			if (*source).Tolerations != nil {
				consolePartialRenderValues.Tolerations = make([]v1.Toleration, len((*source).Tolerations))
				for j := 0; j < len((*source).Tolerations); j++ {
					consolePartialRenderValues.Tolerations[j] = v1TolerationToV1Toleration((*source).Tolerations[j])
				}
			}
			consolePartialRenderValues.Affinity = pV1AffinityToPV1Affinity((*source).Affinity)
			if (*source).TopologySpreadConstraints != nil {
				consolePartialRenderValues.TopologySpreadConstraints = make([]v1.TopologySpreadConstraint, len((*source).TopologySpreadConstraints))
				for k := 0; k < len((*source).TopologySpreadConstraints); k++ {
					consolePartialRenderValues.TopologySpreadConstraints[k] = v1TopologySpreadConstraintToV1TopologySpreadConstraint((*source).TopologySpreadConstraints[k])
				}
			}
			if (*source).PriorityClassName != nil {
				xstring := *(*source).PriorityClassName
				consolePartialRenderValues.PriorityClassName = &xstring
			}
			mapStringUnknown, err := conv_runtime_RawExtension_To_mapany((*source).Config)
			if err != nil {
				return nil, err
			}
			consolePartialRenderValues.Config = mapStringUnknown
			if (*source).ExtraEnv != nil {
				consolePartialRenderValues.ExtraEnv = make([]v1.EnvVar, len((*source).ExtraEnv))
				for l := 0; l < len((*source).ExtraEnv); l++ {
					consolePartialRenderValues.ExtraEnv[l] = conv_corev1_EnvVar_To_corev1EnvVar((*source).ExtraEnv[l])
				}
			}
			if (*source).ExtraEnvFrom != nil {
				consolePartialRenderValues.ExtraEnvFrom = make([]v1.EnvFromSource, len((*source).ExtraEnvFrom))
				for m := 0; m < len((*source).ExtraEnvFrom); m++ {
					consolePartialRenderValues.ExtraEnvFrom[m] = v1EnvFromSourceToV1EnvFromSource((*source).ExtraEnvFrom[m])
				}
			}
			if (*source).ExtraVolumes != nil {
				consolePartialRenderValues.ExtraVolumes = make([]v1.Volume, len((*source).ExtraVolumes))
				for n := 0; n < len((*source).ExtraVolumes); n++ {
					consolePartialRenderValues.ExtraVolumes[n] = conv_corev1_Volume_To_corev1_Volume((*source).ExtraVolumes[n])
				}
			}
			if (*source).ExtraVolumeMounts != nil {
				consolePartialRenderValues.ExtraVolumeMounts = make([]v1.VolumeMount, len((*source).ExtraVolumeMounts))
				for o := 0; o < len((*source).ExtraVolumeMounts); o++ {
					consolePartialRenderValues.ExtraVolumeMounts[o] = v1VolumeMountToV1VolumeMount((*source).ExtraVolumeMounts[o])
				}
			}
			if (*source).ExtraContainers != nil {
				consolePartialRenderValues.ExtraContainers = make([]v1.Container, len((*source).ExtraContainers))
				for p := 0; p < len((*source).ExtraContainers); p++ {
					consolePartialRenderValues.ExtraContainers[p] = v1ContainerToV1Container((*source).ExtraContainers[p])
				}
			}
			if (*source).ExtraContainerPorts != nil {
				consolePartialRenderValues.ExtraContainerPorts = make([]v1.ContainerPort, len((*source).ExtraContainerPorts))
				for q := 0; q < len((*source).ExtraContainerPorts); q++ {
					consolePartialRenderValues.ExtraContainerPorts[q] = v1ContainerPortToV1ContainerPort((*source).ExtraContainerPorts[q])
				}
			}
			if (*source).SecretMounts != nil {
				consolePartialRenderValues.SecretMounts = make([]v3.PartialSecretMount, len((*source).SecretMounts))
				for r := 0; r < len((*source).SecretMounts); r++ {
					consolePartialRenderValues.SecretMounts[r] = v1alpha2SecretMountToConsolePartialSecretMount((*source).SecretMounts[r])
				}
			}
			consolePartialRenderValues.Secret = v1alpha2SecretConfigToPConsolePartialSecretConfig((*source).Secret)
			consolePartialRenderValues.LicenseSecretRef = pV1SecretKeySelectorToPV1SecretKeySelector((*source).LicenseSecretRef)
			consolePartialRenderValues.LivenessProbe = pV1ProbeToPV1Probe((*source).LivenessProbe)
			consolePartialRenderValues.ReadinessProbe = pV1ProbeToPV1Probe((*source).ReadinessProbe)
			consolePartialRenderValues.Deployment = autoconv_DeploymentConfig_console_PartialDeploymentConfig((*source).Deployment)
			consolePartialRenderValues.Strategy = pV1DeploymentStrategyToPV1DeploymentStrategy((*source).Strategy)
			pConsolePartialRenderValues = &consolePartialRenderValues
		}
		return pConsolePartialRenderValues, nil
	}
	ConvertStaticConfigToIR = func(context string, source *StaticConfigurationSource) *ir.StaticConfigurationSource {
		var pIrStaticConfigurationSource *ir.StaticConfigurationSource
		if source != nil {
			var irStaticConfigurationSource ir.StaticConfigurationSource
			irStaticConfigurationSource.Kafka = pV1alpha2KafkaAPISpecToPIrKafkaAPISpec((*source).Kafka, context)
			irStaticConfigurationSource.Admin = autoconv_AdminAPISpec_To_ir_AdminAPISpec((*source).Admin, context)
			irStaticConfigurationSource.SchemaRegistry = pV1alpha2SchemaRegistrySpecToPIrSchemaRegistrySpec((*source).SchemaRegistry, context)
			pIrStaticConfigurationSource = &irStaticConfigurationSource
		}
		return pIrStaticConfigurationSource
	}
	autoconv_AdminAPISpec_To_ir_AdminAPISpec = func(source *AdminAPISpec, context string) *ir.AdminAPISpec {
		var pIrAdminAPISpec *ir.AdminAPISpec
		if source != nil {
			var irAdminAPISpec ir.AdminAPISpec
			if (*source).URLs != nil {
				irAdminAPISpec.URLs = make([]string, len((*source).URLs))
				for i := 0; i < len((*source).URLs); i++ {
					irAdminAPISpec.URLs[i] = (*source).URLs[i]
				}
			}
			irAdminAPISpec.TLS = autoconv_CommonTLS_To_ir_CommonTLS((*source).TLS, context)
			irAdminAPISpec.Auth = pV1alpha2AdminSASLToPIrAdminAuth((*source).SASL, context)
			pIrAdminAPISpec = &irAdminAPISpec
		}
		return pIrAdminAPISpec
	}
	autoconv_CommonTLS_To_ir_CommonTLS = func(source *CommonTLS, context string) *ir.CommonTLS {
		var pIrCommonTLS *ir.CommonTLS
		if source != nil {
			var irCommonTLS ir.CommonTLS
			irCommonTLS.CaCert = conv_SecretKeyRef_To_ir_ObjectKeyRef((*source).CaCert, context)
			irCommonTLS.Cert = pV1alpha2SecretKeyRefToPIrSecretKeyRef((*source).Cert, context)
			irCommonTLS.Key = pV1alpha2SecretKeyRefToPIrSecretKeyRef((*source).Key, context)
			irCommonTLS.InsecureSkipTLSVerify = (*source).InsecureSkipTLSVerify
			pIrCommonTLS = &irCommonTLS
		}
		return pIrCommonTLS
	}
	autoconv_DeploymentConfig_console_PartialDeploymentConfig = func(source *DeploymentConfig) *v3.PartialDeploymentConfig {
		var pConsolePartialDeploymentConfig *v3.PartialDeploymentConfig
		if source != nil {
			var consolePartialDeploymentConfig v3.PartialDeploymentConfig
			if (*source).Command != nil {
				consolePartialDeploymentConfig.Command = make([]string, len((*source).Command))
				for i := 0; i < len((*source).Command); i++ {
					consolePartialDeploymentConfig.Command[i] = (*source).Command[i]
				}
			}
			if (*source).ExtraArgs != nil {
				consolePartialDeploymentConfig.ExtraArgs = make([]string, len((*source).ExtraArgs))
				for j := 0; j < len((*source).ExtraArgs); j++ {
					consolePartialDeploymentConfig.ExtraArgs[j] = (*source).ExtraArgs[j]
				}
			}
			pConsolePartialDeploymentConfig = &consolePartialDeploymentConfig
		}
		return pConsolePartialDeploymentConfig
	}
	autoconv_SecretKeyRef_To_ir_SecretKeyRef = func(source SecretKeyRef, context string) ir.SecretKeyRef {
		var irSecretKeyRef ir.SecretKeyRef
		irSecretKeyRef.Namespace = getNamespace(context)
		irSecretKeyRef.Name = source.Name
		irSecretKeyRef.Key = source.Key
		return irSecretKeyRef
	}
	autoconv_ServiceAccountConfig_To_console_PartialServiceAccountConfig = func(source *ServiceAccountConfig) *v3.PartialServiceAccountConfig {
		var pConsolePartialServiceAccountConfig *v3.PartialServiceAccountConfig
		if source != nil {
			var consolePartialServiceAccountConfig v3.PartialServiceAccountConfig
			if (*source).AutomountServiceAccountToken != nil {
				xbool := *(*source).AutomountServiceAccountToken
				consolePartialServiceAccountConfig.AutomountServiceAccountToken = &xbool
			}
			if (*source).Annotations != nil {
				consolePartialServiceAccountConfig.Annotations = make(map[string]string, len((*source).Annotations))
				for key, value := range (*source).Annotations {
					consolePartialServiceAccountConfig.Annotations[key] = value
				}
			}
			if (*source).Name != nil {
				xstring := *(*source).Name
				consolePartialServiceAccountConfig.Name = &xstring
			}
			pConsolePartialServiceAccountConfig = &consolePartialServiceAccountConfig
		}
		return pConsolePartialServiceAccountConfig
	}
}
func intstrIntOrStringToIntstrIntOrString(source intstr.IntOrString) intstr.IntOrString {
	var intstrIntOrString intstr.IntOrString
	intstrIntOrString.Type = intstr.Type(source.Type)
	intstrIntOrString.IntVal = source.IntVal
	intstrIntOrString.StrVal = source.StrVal
	return intstrIntOrString
}
func pIntstrIntOrStringToPIntstrIntOrString(source *intstr.IntOrString) *intstr.IntOrString {
	var pIntstrIntOrString *intstr.IntOrString
	if source != nil {
		intstrIntOrString := intstrIntOrStringToIntstrIntOrString((*source))
		pIntstrIntOrString = &intstrIntOrString
	}
	return pIntstrIntOrString
}
func pV1AffinityToPV1Affinity(source *v1.Affinity) *v1.Affinity {
	var pV1Affinity *v1.Affinity
	if source != nil {
		var v1Affinity v1.Affinity
		v1Affinity.NodeAffinity = pV1NodeAffinityToPV1NodeAffinity((*source).NodeAffinity)
		v1Affinity.PodAffinity = pV1PodAffinityToPV1PodAffinity((*source).PodAffinity)
		v1Affinity.PodAntiAffinity = pV1PodAntiAffinityToPV1PodAntiAffinity((*source).PodAntiAffinity)
		pV1Affinity = &v1Affinity
	}
	return pV1Affinity
}
func pV1AppArmorProfileToPV1AppArmorProfile(source *v1.AppArmorProfile) *v1.AppArmorProfile {
	var pV1AppArmorProfile *v1.AppArmorProfile
	if source != nil {
		var v1AppArmorProfile v1.AppArmorProfile
		v1AppArmorProfile.Type = v1.AppArmorProfileType((*source).Type)
		if (*source).LocalhostProfile != nil {
			xstring := *(*source).LocalhostProfile
			v1AppArmorProfile.LocalhostProfile = &xstring
		}
		pV1AppArmorProfile = &v1AppArmorProfile
	}
	return pV1AppArmorProfile
}
func pV1CapabilitiesToPV1Capabilities(source *v1.Capabilities) *v1.Capabilities {
	var pV1Capabilities *v1.Capabilities
	if source != nil {
		var v1Capabilities v1.Capabilities
		if (*source).Add != nil {
			v1Capabilities.Add = make([]v1.Capability, len((*source).Add))
			for i := 0; i < len((*source).Add); i++ {
				v1Capabilities.Add[i] = v1CapabilityToV1Capability((*source).Add[i])
			}
		}
		if (*source).Drop != nil {
			v1Capabilities.Drop = make([]v1.Capability, len((*source).Drop))
			for j := 0; j < len((*source).Drop); j++ {
				v1Capabilities.Drop[j] = v1CapabilityToV1Capability((*source).Drop[j])
			}
		}
		pV1Capabilities = &v1Capabilities
	}
	return pV1Capabilities
}
func pV1ConfigMapEnvSourceToPV1ConfigMapEnvSource(source *v1.ConfigMapEnvSource) *v1.ConfigMapEnvSource {
	var pV1ConfigMapEnvSource *v1.ConfigMapEnvSource
	if source != nil {
		var v1ConfigMapEnvSource v1.ConfigMapEnvSource
		v1ConfigMapEnvSource.LocalObjectReference = v1LocalObjectReferenceToV1LocalObjectReference((*source).LocalObjectReference)
		if (*source).Optional != nil {
			xbool := *(*source).Optional
			v1ConfigMapEnvSource.Optional = &xbool
		}
		pV1ConfigMapEnvSource = &v1ConfigMapEnvSource
	}
	return pV1ConfigMapEnvSource
}
func pV1DeploymentStrategyToPV1DeploymentStrategy(source *v11.DeploymentStrategy) *v11.DeploymentStrategy {
	var pV1DeploymentStrategy *v11.DeploymentStrategy
	if source != nil {
		var v1DeploymentStrategy v11.DeploymentStrategy
		v1DeploymentStrategy.Type = v11.DeploymentStrategyType((*source).Type)
		v1DeploymentStrategy.RollingUpdate = pV1RollingUpdateDeploymentToPV1RollingUpdateDeployment((*source).RollingUpdate)
		pV1DeploymentStrategy = &v1DeploymentStrategy
	}
	return pV1DeploymentStrategy
}
func pV1ExecActionToPV1ExecAction(source *v1.ExecAction) *v1.ExecAction {
	var pV1ExecAction *v1.ExecAction
	if source != nil {
		var v1ExecAction v1.ExecAction
		if (*source).Command != nil {
			v1ExecAction.Command = make([]string, len((*source).Command))
			for i := 0; i < len((*source).Command); i++ {
				v1ExecAction.Command[i] = (*source).Command[i]
			}
		}
		pV1ExecAction = &v1ExecAction
	}
	return pV1ExecAction
}
func pV1GRPCActionToPV1GRPCAction(source *v1.GRPCAction) *v1.GRPCAction {
	var pV1GRPCAction *v1.GRPCAction
	if source != nil {
		var v1GRPCAction v1.GRPCAction
		v1GRPCAction.Port = (*source).Port
		if (*source).Service != nil {
			xstring := *(*source).Service
			v1GRPCAction.Service = &xstring
		}
		pV1GRPCAction = &v1GRPCAction
	}
	return pV1GRPCAction
}
func pV1HTTPGetActionToPV1HTTPGetAction(source *v1.HTTPGetAction) *v1.HTTPGetAction {
	var pV1HTTPGetAction *v1.HTTPGetAction
	if source != nil {
		var v1HTTPGetAction v1.HTTPGetAction
		v1HTTPGetAction.Path = (*source).Path
		v1HTTPGetAction.Port = intstrIntOrStringToIntstrIntOrString((*source).Port)
		v1HTTPGetAction.Host = (*source).Host
		v1HTTPGetAction.Scheme = v1.URIScheme((*source).Scheme)
		if (*source).HTTPHeaders != nil {
			v1HTTPGetAction.HTTPHeaders = make([]v1.HTTPHeader, len((*source).HTTPHeaders))
			for i := 0; i < len((*source).HTTPHeaders); i++ {
				v1HTTPGetAction.HTTPHeaders[i] = v1HTTPHeaderToV1HTTPHeader((*source).HTTPHeaders[i])
			}
		}
		pV1HTTPGetAction = &v1HTTPGetAction
	}
	return pV1HTTPGetAction
}
func pV1LabelSelectorToPV1LabelSelector(source *v12.LabelSelector) *v12.LabelSelector {
	var pV1LabelSelector *v12.LabelSelector
	if source != nil {
		var v1LabelSelector v12.LabelSelector
		if (*source).MatchLabels != nil {
			v1LabelSelector.MatchLabels = make(map[string]string, len((*source).MatchLabels))
			for key, value := range (*source).MatchLabels {
				v1LabelSelector.MatchLabels[key] = value
			}
		}
		if (*source).MatchExpressions != nil {
			v1LabelSelector.MatchExpressions = make([]v12.LabelSelectorRequirement, len((*source).MatchExpressions))
			for i := 0; i < len((*source).MatchExpressions); i++ {
				v1LabelSelector.MatchExpressions[i] = v1LabelSelectorRequirementToV1LabelSelectorRequirement((*source).MatchExpressions[i])
			}
		}
		pV1LabelSelector = &v1LabelSelector
	}
	return pV1LabelSelector
}
func pV1LifecycleHandlerToPV1LifecycleHandler(source *v1.LifecycleHandler) *v1.LifecycleHandler {
	var pV1LifecycleHandler *v1.LifecycleHandler
	if source != nil {
		var v1LifecycleHandler v1.LifecycleHandler
		v1LifecycleHandler.Exec = pV1ExecActionToPV1ExecAction((*source).Exec)
		v1LifecycleHandler.HTTPGet = pV1HTTPGetActionToPV1HTTPGetAction((*source).HTTPGet)
		v1LifecycleHandler.TCPSocket = pV1TCPSocketActionToPV1TCPSocketAction((*source).TCPSocket)
		v1LifecycleHandler.Sleep = pV1SleepActionToPV1SleepAction((*source).Sleep)
		pV1LifecycleHandler = &v1LifecycleHandler
	}
	return pV1LifecycleHandler
}
func pV1LifecycleToPV1Lifecycle(source *v1.Lifecycle) *v1.Lifecycle {
	var pV1Lifecycle *v1.Lifecycle
	if source != nil {
		var v1Lifecycle v1.Lifecycle
		v1Lifecycle.PostStart = pV1LifecycleHandlerToPV1LifecycleHandler((*source).PostStart)
		v1Lifecycle.PreStop = pV1LifecycleHandlerToPV1LifecycleHandler((*source).PreStop)
		if (*source).StopSignal != nil {
			v1Signal := v1.Signal(*(*source).StopSignal)
			v1Lifecycle.StopSignal = &v1Signal
		}
		pV1Lifecycle = &v1Lifecycle
	}
	return pV1Lifecycle
}
func pV1NodeAffinityToPV1NodeAffinity(source *v1.NodeAffinity) *v1.NodeAffinity {
	var pV1NodeAffinity *v1.NodeAffinity
	if source != nil {
		var v1NodeAffinity v1.NodeAffinity
		v1NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution = pV1NodeSelectorToPV1NodeSelector((*source).RequiredDuringSchedulingIgnoredDuringExecution)
		if (*source).PreferredDuringSchedulingIgnoredDuringExecution != nil {
			v1NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution = make([]v1.PreferredSchedulingTerm, len((*source).PreferredDuringSchedulingIgnoredDuringExecution))
			for i := 0; i < len((*source).PreferredDuringSchedulingIgnoredDuringExecution); i++ {
				v1NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i] = v1PreferredSchedulingTermToV1PreferredSchedulingTerm((*source).PreferredDuringSchedulingIgnoredDuringExecution[i])
			}
		}
		pV1NodeAffinity = &v1NodeAffinity
	}
	return pV1NodeAffinity
}
func pV1NodeSelectorToPV1NodeSelector(source *v1.NodeSelector) *v1.NodeSelector {
	var pV1NodeSelector *v1.NodeSelector
	if source != nil {
		var v1NodeSelector v1.NodeSelector
		if (*source).NodeSelectorTerms != nil {
			v1NodeSelector.NodeSelectorTerms = make([]v1.NodeSelectorTerm, len((*source).NodeSelectorTerms))
			for i := 0; i < len((*source).NodeSelectorTerms); i++ {
				v1NodeSelector.NodeSelectorTerms[i] = v1NodeSelectorTermToV1NodeSelectorTerm((*source).NodeSelectorTerms[i])
			}
		}
		pV1NodeSelector = &v1NodeSelector
	}
	return pV1NodeSelector
}
func pV1PodAffinityToPV1PodAffinity(source *v1.PodAffinity) *v1.PodAffinity {
	var pV1PodAffinity *v1.PodAffinity
	if source != nil {
		var v1PodAffinity v1.PodAffinity
		if (*source).RequiredDuringSchedulingIgnoredDuringExecution != nil {
			v1PodAffinity.RequiredDuringSchedulingIgnoredDuringExecution = make([]v1.PodAffinityTerm, len((*source).RequiredDuringSchedulingIgnoredDuringExecution))
			for i := 0; i < len((*source).RequiredDuringSchedulingIgnoredDuringExecution); i++ {
				v1PodAffinity.RequiredDuringSchedulingIgnoredDuringExecution[i] = v1PodAffinityTermToV1PodAffinityTerm((*source).RequiredDuringSchedulingIgnoredDuringExecution[i])
			}
		}
		if (*source).PreferredDuringSchedulingIgnoredDuringExecution != nil {
			v1PodAffinity.PreferredDuringSchedulingIgnoredDuringExecution = make([]v1.WeightedPodAffinityTerm, len((*source).PreferredDuringSchedulingIgnoredDuringExecution))
			for j := 0; j < len((*source).PreferredDuringSchedulingIgnoredDuringExecution); j++ {
				v1PodAffinity.PreferredDuringSchedulingIgnoredDuringExecution[j] = v1WeightedPodAffinityTermToV1WeightedPodAffinityTerm((*source).PreferredDuringSchedulingIgnoredDuringExecution[j])
			}
		}
		pV1PodAffinity = &v1PodAffinity
	}
	return pV1PodAffinity
}
func pV1PodAntiAffinityToPV1PodAntiAffinity(source *v1.PodAntiAffinity) *v1.PodAntiAffinity {
	var pV1PodAntiAffinity *v1.PodAntiAffinity
	if source != nil {
		var v1PodAntiAffinity v1.PodAntiAffinity
		if (*source).RequiredDuringSchedulingIgnoredDuringExecution != nil {
			v1PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution = make([]v1.PodAffinityTerm, len((*source).RequiredDuringSchedulingIgnoredDuringExecution))
			for i := 0; i < len((*source).RequiredDuringSchedulingIgnoredDuringExecution); i++ {
				v1PodAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution[i] = v1PodAffinityTermToV1PodAffinityTerm((*source).RequiredDuringSchedulingIgnoredDuringExecution[i])
			}
		}
		if (*source).PreferredDuringSchedulingIgnoredDuringExecution != nil {
			v1PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution = make([]v1.WeightedPodAffinityTerm, len((*source).PreferredDuringSchedulingIgnoredDuringExecution))
			for j := 0; j < len((*source).PreferredDuringSchedulingIgnoredDuringExecution); j++ {
				v1PodAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution[j] = v1WeightedPodAffinityTermToV1WeightedPodAffinityTerm((*source).PreferredDuringSchedulingIgnoredDuringExecution[j])
			}
		}
		pV1PodAntiAffinity = &v1PodAntiAffinity
	}
	return pV1PodAntiAffinity
}
func pV1PodSecurityContextToPV1PodSecurityContext(source *v1.PodSecurityContext) *v1.PodSecurityContext {
	var pV1PodSecurityContext *v1.PodSecurityContext
	if source != nil {
		var v1PodSecurityContext v1.PodSecurityContext
		v1PodSecurityContext.SELinuxOptions = pV1SELinuxOptionsToPV1SELinuxOptions((*source).SELinuxOptions)
		v1PodSecurityContext.WindowsOptions = pV1WindowsSecurityContextOptionsToPV1WindowsSecurityContextOptions((*source).WindowsOptions)
		if (*source).RunAsUser != nil {
			xint64 := *(*source).RunAsUser
			v1PodSecurityContext.RunAsUser = &xint64
		}
		if (*source).RunAsGroup != nil {
			xint642 := *(*source).RunAsGroup
			v1PodSecurityContext.RunAsGroup = &xint642
		}
		if (*source).RunAsNonRoot != nil {
			xbool := *(*source).RunAsNonRoot
			v1PodSecurityContext.RunAsNonRoot = &xbool
		}
		if (*source).SupplementalGroups != nil {
			v1PodSecurityContext.SupplementalGroups = make([]int64, len((*source).SupplementalGroups))
			for i := 0; i < len((*source).SupplementalGroups); i++ {
				v1PodSecurityContext.SupplementalGroups[i] = (*source).SupplementalGroups[i]
			}
		}
		if (*source).SupplementalGroupsPolicy != nil {
			v1SupplementalGroupsPolicy := v1.SupplementalGroupsPolicy(*(*source).SupplementalGroupsPolicy)
			v1PodSecurityContext.SupplementalGroupsPolicy = &v1SupplementalGroupsPolicy
		}
		if (*source).FSGroup != nil {
			xint643 := *(*source).FSGroup
			v1PodSecurityContext.FSGroup = &xint643
		}
		if (*source).Sysctls != nil {
			v1PodSecurityContext.Sysctls = make([]v1.Sysctl, len((*source).Sysctls))
			for j := 0; j < len((*source).Sysctls); j++ {
				v1PodSecurityContext.Sysctls[j] = v1SysctlToV1Sysctl((*source).Sysctls[j])
			}
		}
		if (*source).FSGroupChangePolicy != nil {
			v1PodFSGroupChangePolicy := v1.PodFSGroupChangePolicy(*(*source).FSGroupChangePolicy)
			v1PodSecurityContext.FSGroupChangePolicy = &v1PodFSGroupChangePolicy
		}
		v1PodSecurityContext.SeccompProfile = pV1SeccompProfileToPV1SeccompProfile((*source).SeccompProfile)
		v1PodSecurityContext.AppArmorProfile = pV1AppArmorProfileToPV1AppArmorProfile((*source).AppArmorProfile)
		if (*source).SELinuxChangePolicy != nil {
			v1PodSELinuxChangePolicy := v1.PodSELinuxChangePolicy(*(*source).SELinuxChangePolicy)
			v1PodSecurityContext.SELinuxChangePolicy = &v1PodSELinuxChangePolicy
		}
		pV1PodSecurityContext = &v1PodSecurityContext
	}
	return pV1PodSecurityContext
}
func pV1ProbeToPV1Probe(source *v1.Probe) *v1.Probe {
	var pV1Probe *v1.Probe
	if source != nil {
		var v1Probe v1.Probe
		v1Probe.ProbeHandler = v1ProbeHandlerToV1ProbeHandler((*source).ProbeHandler)
		v1Probe.InitialDelaySeconds = (*source).InitialDelaySeconds
		v1Probe.TimeoutSeconds = (*source).TimeoutSeconds
		v1Probe.PeriodSeconds = (*source).PeriodSeconds
		v1Probe.SuccessThreshold = (*source).SuccessThreshold
		v1Probe.FailureThreshold = (*source).FailureThreshold
		if (*source).TerminationGracePeriodSeconds != nil {
			xint64 := *(*source).TerminationGracePeriodSeconds
			v1Probe.TerminationGracePeriodSeconds = &xint64
		}
		pV1Probe = &v1Probe
	}
	return pV1Probe
}
func pV1ResourceRequirementsToPV1ResourceRequirements(source *v1.ResourceRequirements) *v1.ResourceRequirements {
	var pV1ResourceRequirements *v1.ResourceRequirements
	if source != nil {
		v1ResourceRequirements := conv_corev1_ResourceRequirements_To_corev1_ResourceRequirements((*source))
		pV1ResourceRequirements = &v1ResourceRequirements
	}
	return pV1ResourceRequirements
}
func pV1RollingUpdateDeploymentToPV1RollingUpdateDeployment(source *v11.RollingUpdateDeployment) *v11.RollingUpdateDeployment {
	var pV1RollingUpdateDeployment *v11.RollingUpdateDeployment
	if source != nil {
		var v1RollingUpdateDeployment v11.RollingUpdateDeployment
		v1RollingUpdateDeployment.MaxUnavailable = pIntstrIntOrStringToPIntstrIntOrString((*source).MaxUnavailable)
		v1RollingUpdateDeployment.MaxSurge = pIntstrIntOrStringToPIntstrIntOrString((*source).MaxSurge)
		pV1RollingUpdateDeployment = &v1RollingUpdateDeployment
	}
	return pV1RollingUpdateDeployment
}
func pV1SELinuxOptionsToPV1SELinuxOptions(source *v1.SELinuxOptions) *v1.SELinuxOptions {
	var pV1SELinuxOptions *v1.SELinuxOptions
	if source != nil {
		var v1SELinuxOptions v1.SELinuxOptions
		v1SELinuxOptions.User = (*source).User
		v1SELinuxOptions.Role = (*source).Role
		v1SELinuxOptions.Type = (*source).Type
		v1SELinuxOptions.Level = (*source).Level
		pV1SELinuxOptions = &v1SELinuxOptions
	}
	return pV1SELinuxOptions
}
func pV1SeccompProfileToPV1SeccompProfile(source *v1.SeccompProfile) *v1.SeccompProfile {
	var pV1SeccompProfile *v1.SeccompProfile
	if source != nil {
		var v1SeccompProfile v1.SeccompProfile
		v1SeccompProfile.Type = v1.SeccompProfileType((*source).Type)
		if (*source).LocalhostProfile != nil {
			xstring := *(*source).LocalhostProfile
			v1SeccompProfile.LocalhostProfile = &xstring
		}
		pV1SeccompProfile = &v1SeccompProfile
	}
	return pV1SeccompProfile
}
func pV1SecretEnvSourceToPV1SecretEnvSource(source *v1.SecretEnvSource) *v1.SecretEnvSource {
	var pV1SecretEnvSource *v1.SecretEnvSource
	if source != nil {
		var v1SecretEnvSource v1.SecretEnvSource
		v1SecretEnvSource.LocalObjectReference = v1LocalObjectReferenceToV1LocalObjectReference((*source).LocalObjectReference)
		if (*source).Optional != nil {
			xbool := *(*source).Optional
			v1SecretEnvSource.Optional = &xbool
		}
		pV1SecretEnvSource = &v1SecretEnvSource
	}
	return pV1SecretEnvSource
}
func pV1SecretKeySelectorToPV1SecretKeySelector(source *v1.SecretKeySelector) *v1.SecretKeySelector {
	var pV1SecretKeySelector *v1.SecretKeySelector
	if source != nil {
		var v1SecretKeySelector v1.SecretKeySelector
		v1SecretKeySelector.LocalObjectReference = v1LocalObjectReferenceToV1LocalObjectReference((*source).LocalObjectReference)
		v1SecretKeySelector.Key = (*source).Key
		if (*source).Optional != nil {
			xbool := *(*source).Optional
			v1SecretKeySelector.Optional = &xbool
		}
		pV1SecretKeySelector = &v1SecretKeySelector
	}
	return pV1SecretKeySelector
}
func pV1SecurityContextToPV1SecurityContext(source *v1.SecurityContext) *v1.SecurityContext {
	var pV1SecurityContext *v1.SecurityContext
	if source != nil {
		var v1SecurityContext v1.SecurityContext
		v1SecurityContext.Capabilities = pV1CapabilitiesToPV1Capabilities((*source).Capabilities)
		if (*source).Privileged != nil {
			xbool := *(*source).Privileged
			v1SecurityContext.Privileged = &xbool
		}
		v1SecurityContext.SELinuxOptions = pV1SELinuxOptionsToPV1SELinuxOptions((*source).SELinuxOptions)
		v1SecurityContext.WindowsOptions = pV1WindowsSecurityContextOptionsToPV1WindowsSecurityContextOptions((*source).WindowsOptions)
		if (*source).RunAsUser != nil {
			xint64 := *(*source).RunAsUser
			v1SecurityContext.RunAsUser = &xint64
		}
		if (*source).RunAsGroup != nil {
			xint642 := *(*source).RunAsGroup
			v1SecurityContext.RunAsGroup = &xint642
		}
		if (*source).RunAsNonRoot != nil {
			xbool2 := *(*source).RunAsNonRoot
			v1SecurityContext.RunAsNonRoot = &xbool2
		}
		if (*source).ReadOnlyRootFilesystem != nil {
			xbool3 := *(*source).ReadOnlyRootFilesystem
			v1SecurityContext.ReadOnlyRootFilesystem = &xbool3
		}
		if (*source).AllowPrivilegeEscalation != nil {
			xbool4 := *(*source).AllowPrivilegeEscalation
			v1SecurityContext.AllowPrivilegeEscalation = &xbool4
		}
		if (*source).ProcMount != nil {
			v1ProcMountType := v1.ProcMountType(*(*source).ProcMount)
			v1SecurityContext.ProcMount = &v1ProcMountType
		}
		v1SecurityContext.SeccompProfile = pV1SeccompProfileToPV1SeccompProfile((*source).SeccompProfile)
		v1SecurityContext.AppArmorProfile = pV1AppArmorProfileToPV1AppArmorProfile((*source).AppArmorProfile)
		pV1SecurityContext = &v1SecurityContext
	}
	return pV1SecurityContext
}
func pV1SleepActionToPV1SleepAction(source *v1.SleepAction) *v1.SleepAction {
	var pV1SleepAction *v1.SleepAction
	if source != nil {
		var v1SleepAction v1.SleepAction
		v1SleepAction.Seconds = (*source).Seconds
		pV1SleepAction = &v1SleepAction
	}
	return pV1SleepAction
}
func pV1TCPSocketActionToPV1TCPSocketAction(source *v1.TCPSocketAction) *v1.TCPSocketAction {
	var pV1TCPSocketAction *v1.TCPSocketAction
	if source != nil {
		var v1TCPSocketAction v1.TCPSocketAction
		v1TCPSocketAction.Port = intstrIntOrStringToIntstrIntOrString((*source).Port)
		v1TCPSocketAction.Host = (*source).Host
		pV1TCPSocketAction = &v1TCPSocketAction
	}
	return pV1TCPSocketAction
}
func pV1WindowsSecurityContextOptionsToPV1WindowsSecurityContextOptions(source *v1.WindowsSecurityContextOptions) *v1.WindowsSecurityContextOptions {
	var pV1WindowsSecurityContextOptions *v1.WindowsSecurityContextOptions
	if source != nil {
		var v1WindowsSecurityContextOptions v1.WindowsSecurityContextOptions
		if (*source).GMSACredentialSpecName != nil {
			xstring := *(*source).GMSACredentialSpecName
			v1WindowsSecurityContextOptions.GMSACredentialSpecName = &xstring
		}
		if (*source).GMSACredentialSpec != nil {
			xstring2 := *(*source).GMSACredentialSpec
			v1WindowsSecurityContextOptions.GMSACredentialSpec = &xstring2
		}
		if (*source).RunAsUserName != nil {
			xstring3 := *(*source).RunAsUserName
			v1WindowsSecurityContextOptions.RunAsUserName = &xstring3
		}
		if (*source).HostProcess != nil {
			xbool := *(*source).HostProcess
			v1WindowsSecurityContextOptions.HostProcess = &xbool
		}
		pV1WindowsSecurityContextOptions = &v1WindowsSecurityContextOptions
	}
	return pV1WindowsSecurityContextOptions
}
func pV1alpha2AdminSASLToPIrAdminAuth(source *AdminSASL, context string) *ir.AdminAuth {
	var pIrAdminAuth *ir.AdminAuth
	if source != nil {
		var irAdminAuth ir.AdminAuth
		irAdminAuth.Username = (*source).Username
		irAdminAuth.Password = autoconv_SecretKeyRef_To_ir_SecretKeyRef((*source).Password, context)
		pIrAdminAuth = &irAdminAuth
	}
	return pIrAdminAuth
}
func pV1alpha2AuthenticationSecretsToPConsolePartialAuthenticationSecrets(source *AuthenticationSecrets) *v3.PartialAuthenticationSecrets {
	var pConsolePartialAuthenticationSecrets *v3.PartialAuthenticationSecrets
	if source != nil {
		var consolePartialAuthenticationSecrets v3.PartialAuthenticationSecrets
		if (*source).JWTSigningKey != nil {
			xstring := *(*source).JWTSigningKey
			consolePartialAuthenticationSecrets.JWTSigningKey = &xstring
		}
		consolePartialAuthenticationSecrets.OIDC = pV1alpha2OIDCLoginSecretsToPConsolePartialOIDCLoginSecrets((*source).OIDC)
		pConsolePartialAuthenticationSecrets = &consolePartialAuthenticationSecrets
	}
	return pConsolePartialAuthenticationSecrets
}
func pV1alpha2AutoScalingToPConsolePartialAutoScaling(source *AutoScaling) *v3.PartialAutoScaling {
	var pConsolePartialAutoScaling *v3.PartialAutoScaling
	if source != nil {
		var consolePartialAutoScaling v3.PartialAutoScaling
		if (*source).Enabled != nil {
			xbool := *(*source).Enabled
			consolePartialAutoScaling.Enabled = &xbool
		}
		if (*source).MinReplicas != nil {
			xint32 := *(*source).MinReplicas
			consolePartialAutoScaling.MinReplicas = &xint32
		}
		if (*source).MaxReplicas != nil {
			xint322 := *(*source).MaxReplicas
			consolePartialAutoScaling.MaxReplicas = &xint322
		}
		if (*source).TargetCPUUtilizationPercentage != nil {
			xint323 := *(*source).TargetCPUUtilizationPercentage
			consolePartialAutoScaling.TargetCPUUtilizationPercentage = &xint323
		}
		if (*source).TargetMemoryUtilizationPercentage != nil {
			xint324 := *(*source).TargetMemoryUtilizationPercentage
			consolePartialAutoScaling.TargetMemoryUtilizationPercentage = &xint324
		}
		pConsolePartialAutoScaling = &consolePartialAutoScaling
	}
	return pConsolePartialAutoScaling
}
func pV1alpha2ImageToPConsolePartialImage(source *Image) *v3.PartialImage {
	var pConsolePartialImage *v3.PartialImage
	if source != nil {
		var consolePartialImage v3.PartialImage
		if (*source).Registry != nil {
			xstring := *(*source).Registry
			consolePartialImage.Registry = &xstring
		}
		if (*source).Repository != nil {
			xstring2 := *(*source).Repository
			consolePartialImage.Repository = &xstring2
		}
		if (*source).PullPolicy != nil {
			v1PullPolicy := v1.PullPolicy(*(*source).PullPolicy)
			consolePartialImage.PullPolicy = &v1PullPolicy
		}
		if (*source).Tag != nil {
			xstring3 := *(*source).Tag
			consolePartialImage.Tag = &xstring3
		}
		pConsolePartialImage = &consolePartialImage
	}
	return pConsolePartialImage
}
func pV1alpha2IngressConfigToPConsolePartialIngressConfig(source *IngressConfig) *v3.PartialIngressConfig {
	var pConsolePartialIngressConfig *v3.PartialIngressConfig
	if source != nil {
		var consolePartialIngressConfig v3.PartialIngressConfig
		if (*source).Enabled != nil {
			xbool := *(*source).Enabled
			consolePartialIngressConfig.Enabled = &xbool
		}
		if (*source).ClassName != nil {
			xstring := *(*source).ClassName
			consolePartialIngressConfig.ClassName = &xstring
		}
		if (*source).Annotations != nil {
			consolePartialIngressConfig.Annotations = make(map[string]string, len((*source).Annotations))
			for key, value := range (*source).Annotations {
				consolePartialIngressConfig.Annotations[key] = value
			}
		}
		if (*source).Hosts != nil {
			consolePartialIngressConfig.Hosts = make([]v3.PartialIngressHost, len((*source).Hosts))
			for i := 0; i < len((*source).Hosts); i++ {
				consolePartialIngressConfig.Hosts[i] = v1alpha2IngressHostToConsolePartialIngressHost((*source).Hosts[i])
			}
		}
		if (*source).TLS != nil {
			consolePartialIngressConfig.TLS = make([]v13.IngressTLS, len((*source).TLS))
			for j := 0; j < len((*source).TLS); j++ {
				consolePartialIngressConfig.TLS[j] = v1IngressTLSToV1IngressTLS((*source).TLS[j])
			}
		}
		pConsolePartialIngressConfig = &consolePartialIngressConfig
	}
	return pConsolePartialIngressConfig
}
func pV1alpha2KafkaAPISpecToPIrKafkaAPISpec(source *KafkaAPISpec, context string) *ir.KafkaAPISpec {
	var pIrKafkaAPISpec *ir.KafkaAPISpec
	if source != nil {
		var irKafkaAPISpec ir.KafkaAPISpec
		if (*source).Brokers != nil {
			irKafkaAPISpec.Brokers = make([]string, len((*source).Brokers))
			for i := 0; i < len((*source).Brokers); i++ {
				irKafkaAPISpec.Brokers[i] = (*source).Brokers[i]
			}
		}
		irKafkaAPISpec.TLS = autoconv_CommonTLS_To_ir_CommonTLS((*source).TLS, context)
		irKafkaAPISpec.SASL = pV1alpha2KafkaSASLToPIrKafkaSASL((*source).SASL, context)
		pIrKafkaAPISpec = &irKafkaAPISpec
	}
	return pIrKafkaAPISpec
}
func pV1alpha2KafkaSASLToPIrKafkaSASL(source *KafkaSASL, context string) *ir.KafkaSASL {
	var pIrKafkaSASL *ir.KafkaSASL
	if source != nil {
		var irKafkaSASL ir.KafkaSASL
		irKafkaSASL.Username = (*source).Username
		irKafkaSASL.Password = autoconv_SecretKeyRef_To_ir_SecretKeyRef((*source).Password, context)
		irKafkaSASL.Mechanism = ir.SASLMechanism((*source).Mechanism)
		irKafkaSASL.OAUth = v1alpha2KafkaSASLOAuthBearerToIrKafkaSASLOAuthBearer((*source).OAUth, context)
		irKafkaSASL.GSSAPIConfig = v1alpha2KafkaSASLGSSAPIToIrKafkaSASLGSSAPI((*source).GSSAPIConfig, context)
		irKafkaSASL.AWSMskIam = v1alpha2KafkaSASLAWSMskIamToIrKafkaSASLAWSMskIam((*source).AWSMskIam, context)
		pIrKafkaSASL = &irKafkaSASL
	}
	return pIrKafkaSASL
}
func pV1alpha2KafkaSecretsToPConsolePartialKafkaSecrets(source *KafkaSecrets) *v3.PartialKafkaSecrets {
	var pConsolePartialKafkaSecrets *v3.PartialKafkaSecrets
	if source != nil {
		var consolePartialKafkaSecrets v3.PartialKafkaSecrets
		if (*source).SASLPassword != nil {
			xstring := *(*source).SASLPassword
			consolePartialKafkaSecrets.SASLPassword = &xstring
		}
		if (*source).AWSMSKIAMSecretKey != nil {
			xstring2 := *(*source).AWSMSKIAMSecretKey
			consolePartialKafkaSecrets.AWSMSKIAMSecretKey = &xstring2
		}
		if (*source).TLSCA != nil {
			xstring3 := *(*source).TLSCA
			consolePartialKafkaSecrets.TLSCA = &xstring3
		}
		if (*source).TLSCert != nil {
			xstring4 := *(*source).TLSCert
			consolePartialKafkaSecrets.TLSCert = &xstring4
		}
		if (*source).TLSKey != nil {
			xstring5 := *(*source).TLSKey
			consolePartialKafkaSecrets.TLSKey = &xstring5
		}
		if (*source).TLSPassphrase != nil {
			xstring6 := *(*source).TLSPassphrase
			consolePartialKafkaSecrets.TLSPassphrase = &xstring6
		}
		pConsolePartialKafkaSecrets = &consolePartialKafkaSecrets
	}
	return pConsolePartialKafkaSecrets
}
func pV1alpha2OIDCLoginSecretsToPConsolePartialOIDCLoginSecrets(source *OIDCLoginSecrets) *v3.PartialOIDCLoginSecrets {
	var pConsolePartialOIDCLoginSecrets *v3.PartialOIDCLoginSecrets
	if source != nil {
		var consolePartialOIDCLoginSecrets v3.PartialOIDCLoginSecrets
		if (*source).ClientSecret != nil {
			xstring := *(*source).ClientSecret
			consolePartialOIDCLoginSecrets.ClientSecret = &xstring
		}
		pConsolePartialOIDCLoginSecrets = &consolePartialOIDCLoginSecrets
	}
	return pConsolePartialOIDCLoginSecrets
}
func pV1alpha2RedpandaAdminAPISecretsToPConsolePartialRedpandaAdminAPISecrets(source *RedpandaAdminAPISecrets) *v3.PartialRedpandaAdminAPISecrets {
	var pConsolePartialRedpandaAdminAPISecrets *v3.PartialRedpandaAdminAPISecrets
	if source != nil {
		var consolePartialRedpandaAdminAPISecrets v3.PartialRedpandaAdminAPISecrets
		if (*source).Password != nil {
			xstring := *(*source).Password
			consolePartialRedpandaAdminAPISecrets.Password = &xstring
		}
		if (*source).TLSCA != nil {
			xstring2 := *(*source).TLSCA
			consolePartialRedpandaAdminAPISecrets.TLSCA = &xstring2
		}
		if (*source).TLSCert != nil {
			xstring3 := *(*source).TLSCert
			consolePartialRedpandaAdminAPISecrets.TLSCert = &xstring3
		}
		if (*source).TLSKey != nil {
			xstring4 := *(*source).TLSKey
			consolePartialRedpandaAdminAPISecrets.TLSKey = &xstring4
		}
		pConsolePartialRedpandaAdminAPISecrets = &consolePartialRedpandaAdminAPISecrets
	}
	return pConsolePartialRedpandaAdminAPISecrets
}
func pV1alpha2RedpandaSecretsToPConsolePartialRedpandaSecrets(source *RedpandaSecrets) *v3.PartialRedpandaSecrets {
	var pConsolePartialRedpandaSecrets *v3.PartialRedpandaSecrets
	if source != nil {
		var consolePartialRedpandaSecrets v3.PartialRedpandaSecrets
		consolePartialRedpandaSecrets.AdminAPI = pV1alpha2RedpandaAdminAPISecretsToPConsolePartialRedpandaAdminAPISecrets((*source).AdminAPI)
		pConsolePartialRedpandaSecrets = &consolePartialRedpandaSecrets
	}
	return pConsolePartialRedpandaSecrets
}
func pV1alpha2SchemaRegistrySASLToPIrSchemaRegistrySASL(source *SchemaRegistrySASL, context string) *ir.SchemaRegistrySASL {
	var pIrSchemaRegistrySASL *ir.SchemaRegistrySASL
	if source != nil {
		var irSchemaRegistrySASL ir.SchemaRegistrySASL
		irSchemaRegistrySASL.Username = (*source).Username
		irSchemaRegistrySASL.Password = autoconv_SecretKeyRef_To_ir_SecretKeyRef((*source).Password, context)
		irSchemaRegistrySASL.AuthToken = autoconv_SecretKeyRef_To_ir_SecretKeyRef((*source).AuthToken, context)
		pIrSchemaRegistrySASL = &irSchemaRegistrySASL
	}
	return pIrSchemaRegistrySASL
}
func pV1alpha2SchemaRegistrySecretsToPConsolePartialSchemaRegistrySecrets(source *SchemaRegistrySecrets) *v3.PartialSchemaRegistrySecrets {
	var pConsolePartialSchemaRegistrySecrets *v3.PartialSchemaRegistrySecrets
	if source != nil {
		var consolePartialSchemaRegistrySecrets v3.PartialSchemaRegistrySecrets
		if (*source).BearerToken != nil {
			xstring := *(*source).BearerToken
			consolePartialSchemaRegistrySecrets.BearerToken = &xstring
		}
		if (*source).Password != nil {
			xstring2 := *(*source).Password
			consolePartialSchemaRegistrySecrets.Password = &xstring2
		}
		if (*source).TLSCA != nil {
			xstring3 := *(*source).TLSCA
			consolePartialSchemaRegistrySecrets.TLSCA = &xstring3
		}
		if (*source).TLSCert != nil {
			xstring4 := *(*source).TLSCert
			consolePartialSchemaRegistrySecrets.TLSCert = &xstring4
		}
		if (*source).TLSKey != nil {
			xstring5 := *(*source).TLSKey
			consolePartialSchemaRegistrySecrets.TLSKey = &xstring5
		}
		pConsolePartialSchemaRegistrySecrets = &consolePartialSchemaRegistrySecrets
	}
	return pConsolePartialSchemaRegistrySecrets
}
func pV1alpha2SchemaRegistrySpecToPIrSchemaRegistrySpec(source *SchemaRegistrySpec, context string) *ir.SchemaRegistrySpec {
	var pIrSchemaRegistrySpec *ir.SchemaRegistrySpec
	if source != nil {
		var irSchemaRegistrySpec ir.SchemaRegistrySpec
		if (*source).URLs != nil {
			irSchemaRegistrySpec.URLs = make([]string, len((*source).URLs))
			for i := 0; i < len((*source).URLs); i++ {
				irSchemaRegistrySpec.URLs[i] = (*source).URLs[i]
			}
		}
		irSchemaRegistrySpec.TLS = autoconv_CommonTLS_To_ir_CommonTLS((*source).TLS, context)
		irSchemaRegistrySpec.SASL = pV1alpha2SchemaRegistrySASLToPIrSchemaRegistrySASL((*source).SASL, context)
		pIrSchemaRegistrySpec = &irSchemaRegistrySpec
	}
	return pIrSchemaRegistrySpec
}
func pV1alpha2SecretKeyRefToPIrSecretKeyRef(source *SecretKeyRef, context string) *ir.SecretKeyRef {
	var pIrSecretKeyRef *ir.SecretKeyRef
	if source != nil {
		irSecretKeyRef := autoconv_SecretKeyRef_To_ir_SecretKeyRef((*source), context)
		pIrSecretKeyRef = &irSecretKeyRef
	}
	return pIrSecretKeyRef
}
func pV1alpha2SerdeSecretsToPConsolePartialSerdeSecrets(source *SerdeSecrets) *v3.PartialSerdeSecrets {
	var pConsolePartialSerdeSecrets *v3.PartialSerdeSecrets
	if source != nil {
		var consolePartialSerdeSecrets v3.PartialSerdeSecrets
		if (*source).ProtobufGitBasicAuthPassword != nil {
			xstring := *(*source).ProtobufGitBasicAuthPassword
			consolePartialSerdeSecrets.ProtobufGitBasicAuthPassword = &xstring
		}
		pConsolePartialSerdeSecrets = &consolePartialSerdeSecrets
	}
	return pConsolePartialSerdeSecrets
}
func pV1alpha2ServiceConfigToPConsolePartialServiceConfig(source *ServiceConfig) *v3.PartialServiceConfig {
	var pConsolePartialServiceConfig *v3.PartialServiceConfig
	if source != nil {
		var consolePartialServiceConfig v3.PartialServiceConfig
		if (*source).Type != nil {
			v1ServiceType := v1.ServiceType(*(*source).Type)
			consolePartialServiceConfig.Type = &v1ServiceType
		}
		if (*source).Port != nil {
			xint32 := *(*source).Port
			consolePartialServiceConfig.Port = &xint32
		}
		if (*source).NodePort != nil {
			xint322 := *(*source).NodePort
			consolePartialServiceConfig.NodePort = &xint322
		}
		if (*source).TargetPort != nil {
			xint323 := *(*source).TargetPort
			consolePartialServiceConfig.TargetPort = &xint323
		}
		if (*source).Annotations != nil {
			consolePartialServiceConfig.Annotations = make(map[string]string, len((*source).Annotations))
			for key, value := range (*source).Annotations {
				consolePartialServiceConfig.Annotations[key] = value
			}
		}
		pConsolePartialServiceConfig = &consolePartialServiceConfig
	}
	return pConsolePartialServiceConfig
}
func v1CapabilityToV1Capability(source v1.Capability) v1.Capability {
	return v1.Capability(source)
}
func v1ContainerPortToV1ContainerPort(source v1.ContainerPort) v1.ContainerPort {
	var v1ContainerPort v1.ContainerPort
	v1ContainerPort.Name = source.Name
	v1ContainerPort.HostPort = source.HostPort
	v1ContainerPort.ContainerPort = source.ContainerPort
	v1ContainerPort.Protocol = v1.Protocol(source.Protocol)
	v1ContainerPort.HostIP = source.HostIP
	return v1ContainerPort
}
func v1ContainerResizePolicyToV1ContainerResizePolicy(source v1.ContainerResizePolicy) v1.ContainerResizePolicy {
	var v1ContainerResizePolicy v1.ContainerResizePolicy
	v1ContainerResizePolicy.ResourceName = v1.ResourceName(source.ResourceName)
	v1ContainerResizePolicy.RestartPolicy = v1.ResourceResizeRestartPolicy(source.RestartPolicy)
	return v1ContainerResizePolicy
}
func v1ContainerToV1Container(source v1.Container) v1.Container {
	var v1Container v1.Container
	v1Container.Name = source.Name
	v1Container.Image = source.Image
	if source.Command != nil {
		v1Container.Command = make([]string, len(source.Command))
		for i := 0; i < len(source.Command); i++ {
			v1Container.Command[i] = source.Command[i]
		}
	}
	if source.Args != nil {
		v1Container.Args = make([]string, len(source.Args))
		for j := 0; j < len(source.Args); j++ {
			v1Container.Args[j] = source.Args[j]
		}
	}
	v1Container.WorkingDir = source.WorkingDir
	if source.Ports != nil {
		v1Container.Ports = make([]v1.ContainerPort, len(source.Ports))
		for k := 0; k < len(source.Ports); k++ {
			v1Container.Ports[k] = v1ContainerPortToV1ContainerPort(source.Ports[k])
		}
	}
	if source.EnvFrom != nil {
		v1Container.EnvFrom = make([]v1.EnvFromSource, len(source.EnvFrom))
		for l := 0; l < len(source.EnvFrom); l++ {
			v1Container.EnvFrom[l] = v1EnvFromSourceToV1EnvFromSource(source.EnvFrom[l])
		}
	}
	if source.Env != nil {
		v1Container.Env = make([]v1.EnvVar, len(source.Env))
		for m := 0; m < len(source.Env); m++ {
			v1Container.Env[m] = conv_corev1_EnvVar_To_corev1EnvVar(source.Env[m])
		}
	}
	v1Container.Resources = conv_corev1_ResourceRequirements_To_corev1_ResourceRequirements(source.Resources)
	if source.ResizePolicy != nil {
		v1Container.ResizePolicy = make([]v1.ContainerResizePolicy, len(source.ResizePolicy))
		for n := 0; n < len(source.ResizePolicy); n++ {
			v1Container.ResizePolicy[n] = v1ContainerResizePolicyToV1ContainerResizePolicy(source.ResizePolicy[n])
		}
	}
	if source.RestartPolicy != nil {
		v1ContainerRestartPolicy := v1.ContainerRestartPolicy(*source.RestartPolicy)
		v1Container.RestartPolicy = &v1ContainerRestartPolicy
	}
	if source.VolumeMounts != nil {
		v1Container.VolumeMounts = make([]v1.VolumeMount, len(source.VolumeMounts))
		for o := 0; o < len(source.VolumeMounts); o++ {
			v1Container.VolumeMounts[o] = v1VolumeMountToV1VolumeMount(source.VolumeMounts[o])
		}
	}
	if source.VolumeDevices != nil {
		v1Container.VolumeDevices = make([]v1.VolumeDevice, len(source.VolumeDevices))
		for p := 0; p < len(source.VolumeDevices); p++ {
			v1Container.VolumeDevices[p] = v1VolumeDeviceToV1VolumeDevice(source.VolumeDevices[p])
		}
	}
	v1Container.LivenessProbe = pV1ProbeToPV1Probe(source.LivenessProbe)
	v1Container.ReadinessProbe = pV1ProbeToPV1Probe(source.ReadinessProbe)
	v1Container.StartupProbe = pV1ProbeToPV1Probe(source.StartupProbe)
	v1Container.Lifecycle = pV1LifecycleToPV1Lifecycle(source.Lifecycle)
	v1Container.TerminationMessagePath = source.TerminationMessagePath
	v1Container.TerminationMessagePolicy = v1.TerminationMessagePolicy(source.TerminationMessagePolicy)
	v1Container.ImagePullPolicy = v1.PullPolicy(source.ImagePullPolicy)
	v1Container.SecurityContext = pV1SecurityContextToPV1SecurityContext(source.SecurityContext)
	v1Container.Stdin = source.Stdin
	v1Container.StdinOnce = source.StdinOnce
	v1Container.TTY = source.TTY
	return v1Container
}
func v1EnvFromSourceToV1EnvFromSource(source v1.EnvFromSource) v1.EnvFromSource {
	var v1EnvFromSource v1.EnvFromSource
	v1EnvFromSource.Prefix = source.Prefix
	v1EnvFromSource.ConfigMapRef = pV1ConfigMapEnvSourceToPV1ConfigMapEnvSource(source.ConfigMapRef)
	v1EnvFromSource.SecretRef = pV1SecretEnvSourceToPV1SecretEnvSource(source.SecretRef)
	return v1EnvFromSource
}
func v1HTTPHeaderToV1HTTPHeader(source v1.HTTPHeader) v1.HTTPHeader {
	var v1HTTPHeader v1.HTTPHeader
	v1HTTPHeader.Name = source.Name
	v1HTTPHeader.Value = source.Value
	return v1HTTPHeader
}
func v1IngressTLSToV1IngressTLS(source v13.IngressTLS) v13.IngressTLS {
	var v1IngressTLS v13.IngressTLS
	if source.Hosts != nil {
		v1IngressTLS.Hosts = make([]string, len(source.Hosts))
		for i := 0; i < len(source.Hosts); i++ {
			v1IngressTLS.Hosts[i] = source.Hosts[i]
		}
	}
	v1IngressTLS.SecretName = source.SecretName
	return v1IngressTLS
}
func v1LabelSelectorRequirementToV1LabelSelectorRequirement(source v12.LabelSelectorRequirement) v12.LabelSelectorRequirement {
	var v1LabelSelectorRequirement v12.LabelSelectorRequirement
	v1LabelSelectorRequirement.Key = source.Key
	v1LabelSelectorRequirement.Operator = v12.LabelSelectorOperator(source.Operator)
	if source.Values != nil {
		v1LabelSelectorRequirement.Values = make([]string, len(source.Values))
		for i := 0; i < len(source.Values); i++ {
			v1LabelSelectorRequirement.Values[i] = source.Values[i]
		}
	}
	return v1LabelSelectorRequirement
}
func v1LocalObjectReferenceToV1LocalObjectReference(source v1.LocalObjectReference) v1.LocalObjectReference {
	var v1LocalObjectReference v1.LocalObjectReference
	v1LocalObjectReference.Name = source.Name
	return v1LocalObjectReference
}
func v1NodeInclusionPolicyToV1NodeInclusionPolicy(source v1.NodeInclusionPolicy) v1.NodeInclusionPolicy {
	return v1.NodeInclusionPolicy(source)
}
func v1NodeSelectorRequirementToV1NodeSelectorRequirement(source v1.NodeSelectorRequirement) v1.NodeSelectorRequirement {
	var v1NodeSelectorRequirement v1.NodeSelectorRequirement
	v1NodeSelectorRequirement.Key = source.Key
	v1NodeSelectorRequirement.Operator = v1.NodeSelectorOperator(source.Operator)
	if source.Values != nil {
		v1NodeSelectorRequirement.Values = make([]string, len(source.Values))
		for i := 0; i < len(source.Values); i++ {
			v1NodeSelectorRequirement.Values[i] = source.Values[i]
		}
	}
	return v1NodeSelectorRequirement
}
func v1NodeSelectorTermToV1NodeSelectorTerm(source v1.NodeSelectorTerm) v1.NodeSelectorTerm {
	var v1NodeSelectorTerm v1.NodeSelectorTerm
	if source.MatchExpressions != nil {
		v1NodeSelectorTerm.MatchExpressions = make([]v1.NodeSelectorRequirement, len(source.MatchExpressions))
		for i := 0; i < len(source.MatchExpressions); i++ {
			v1NodeSelectorTerm.MatchExpressions[i] = v1NodeSelectorRequirementToV1NodeSelectorRequirement(source.MatchExpressions[i])
		}
	}
	if source.MatchFields != nil {
		v1NodeSelectorTerm.MatchFields = make([]v1.NodeSelectorRequirement, len(source.MatchFields))
		for j := 0; j < len(source.MatchFields); j++ {
			v1NodeSelectorTerm.MatchFields[j] = v1NodeSelectorRequirementToV1NodeSelectorRequirement(source.MatchFields[j])
		}
	}
	return v1NodeSelectorTerm
}
func v1PodAffinityTermToV1PodAffinityTerm(source v1.PodAffinityTerm) v1.PodAffinityTerm {
	var v1PodAffinityTerm v1.PodAffinityTerm
	v1PodAffinityTerm.LabelSelector = pV1LabelSelectorToPV1LabelSelector(source.LabelSelector)
	if source.Namespaces != nil {
		v1PodAffinityTerm.Namespaces = make([]string, len(source.Namespaces))
		for i := 0; i < len(source.Namespaces); i++ {
			v1PodAffinityTerm.Namespaces[i] = source.Namespaces[i]
		}
	}
	v1PodAffinityTerm.TopologyKey = source.TopologyKey
	v1PodAffinityTerm.NamespaceSelector = pV1LabelSelectorToPV1LabelSelector(source.NamespaceSelector)
	if source.MatchLabelKeys != nil {
		v1PodAffinityTerm.MatchLabelKeys = make([]string, len(source.MatchLabelKeys))
		for j := 0; j < len(source.MatchLabelKeys); j++ {
			v1PodAffinityTerm.MatchLabelKeys[j] = source.MatchLabelKeys[j]
		}
	}
	if source.MismatchLabelKeys != nil {
		v1PodAffinityTerm.MismatchLabelKeys = make([]string, len(source.MismatchLabelKeys))
		for k := 0; k < len(source.MismatchLabelKeys); k++ {
			v1PodAffinityTerm.MismatchLabelKeys[k] = source.MismatchLabelKeys[k]
		}
	}
	return v1PodAffinityTerm
}
func v1PreferredSchedulingTermToV1PreferredSchedulingTerm(source v1.PreferredSchedulingTerm) v1.PreferredSchedulingTerm {
	var v1PreferredSchedulingTerm v1.PreferredSchedulingTerm
	v1PreferredSchedulingTerm.Weight = source.Weight
	v1PreferredSchedulingTerm.Preference = v1NodeSelectorTermToV1NodeSelectorTerm(source.Preference)
	return v1PreferredSchedulingTerm
}
func v1ProbeHandlerToV1ProbeHandler(source v1.ProbeHandler) v1.ProbeHandler {
	var v1ProbeHandler v1.ProbeHandler
	v1ProbeHandler.Exec = pV1ExecActionToPV1ExecAction(source.Exec)
	v1ProbeHandler.HTTPGet = pV1HTTPGetActionToPV1HTTPGetAction(source.HTTPGet)
	v1ProbeHandler.TCPSocket = pV1TCPSocketActionToPV1TCPSocketAction(source.TCPSocket)
	v1ProbeHandler.GRPC = pV1GRPCActionToPV1GRPCAction(source.GRPC)
	return v1ProbeHandler
}
func v1SysctlToV1Sysctl(source v1.Sysctl) v1.Sysctl {
	var v1Sysctl v1.Sysctl
	v1Sysctl.Name = source.Name
	v1Sysctl.Value = source.Value
	return v1Sysctl
}
func v1TolerationToV1Toleration(source v1.Toleration) v1.Toleration {
	var v1Toleration v1.Toleration
	v1Toleration.Key = source.Key
	v1Toleration.Operator = v1.TolerationOperator(source.Operator)
	v1Toleration.Value = source.Value
	v1Toleration.Effect = v1.TaintEffect(source.Effect)
	if source.TolerationSeconds != nil {
		xint64 := *source.TolerationSeconds
		v1Toleration.TolerationSeconds = &xint64
	}
	return v1Toleration
}
func v1TopologySpreadConstraintToV1TopologySpreadConstraint(source v1.TopologySpreadConstraint) v1.TopologySpreadConstraint {
	var v1TopologySpreadConstraint v1.TopologySpreadConstraint
	v1TopologySpreadConstraint.MaxSkew = source.MaxSkew
	v1TopologySpreadConstraint.TopologyKey = source.TopologyKey
	v1TopologySpreadConstraint.WhenUnsatisfiable = v1.UnsatisfiableConstraintAction(source.WhenUnsatisfiable)
	v1TopologySpreadConstraint.LabelSelector = pV1LabelSelectorToPV1LabelSelector(source.LabelSelector)
	if source.MinDomains != nil {
		xint32 := *source.MinDomains
		v1TopologySpreadConstraint.MinDomains = &xint32
	}
	if source.NodeAffinityPolicy != nil {
		v1NodeInclusionPolicy := v1NodeInclusionPolicyToV1NodeInclusionPolicy(*source.NodeAffinityPolicy)
		v1TopologySpreadConstraint.NodeAffinityPolicy = &v1NodeInclusionPolicy
	}
	if source.NodeTaintsPolicy != nil {
		v1NodeInclusionPolicy2 := v1NodeInclusionPolicyToV1NodeInclusionPolicy(*source.NodeTaintsPolicy)
		v1TopologySpreadConstraint.NodeTaintsPolicy = &v1NodeInclusionPolicy2
	}
	if source.MatchLabelKeys != nil {
		v1TopologySpreadConstraint.MatchLabelKeys = make([]string, len(source.MatchLabelKeys))
		for i := 0; i < len(source.MatchLabelKeys); i++ {
			v1TopologySpreadConstraint.MatchLabelKeys[i] = source.MatchLabelKeys[i]
		}
	}
	return v1TopologySpreadConstraint
}
func v1VolumeDeviceToV1VolumeDevice(source v1.VolumeDevice) v1.VolumeDevice {
	var v1VolumeDevice v1.VolumeDevice
	v1VolumeDevice.Name = source.Name
	v1VolumeDevice.DevicePath = source.DevicePath
	return v1VolumeDevice
}
func v1VolumeMountToV1VolumeMount(source v1.VolumeMount) v1.VolumeMount {
	var v1VolumeMount v1.VolumeMount
	v1VolumeMount.Name = source.Name
	v1VolumeMount.ReadOnly = source.ReadOnly
	if source.RecursiveReadOnly != nil {
		v1RecursiveReadOnlyMode := v1.RecursiveReadOnlyMode(*source.RecursiveReadOnly)
		v1VolumeMount.RecursiveReadOnly = &v1RecursiveReadOnlyMode
	}
	v1VolumeMount.MountPath = source.MountPath
	v1VolumeMount.SubPath = source.SubPath
	if source.MountPropagation != nil {
		v1MountPropagationMode := v1.MountPropagationMode(*source.MountPropagation)
		v1VolumeMount.MountPropagation = &v1MountPropagationMode
	}
	v1VolumeMount.SubPathExpr = source.SubPathExpr
	return v1VolumeMount
}
func v1WeightedPodAffinityTermToV1WeightedPodAffinityTerm(source v1.WeightedPodAffinityTerm) v1.WeightedPodAffinityTerm {
	var v1WeightedPodAffinityTerm v1.WeightedPodAffinityTerm
	v1WeightedPodAffinityTerm.Weight = source.Weight
	v1WeightedPodAffinityTerm.PodAffinityTerm = v1PodAffinityTermToV1PodAffinityTerm(source.PodAffinityTerm)
	return v1WeightedPodAffinityTerm
}
func v1alpha2IngressHostToConsolePartialIngressHost(source IngressHost) v3.PartialIngressHost {
	var consolePartialIngressHost v3.PartialIngressHost
	pString := source.Host
	consolePartialIngressHost.Host = &pString
	if source.Paths != nil {
		consolePartialIngressHost.Paths = make([]v3.PartialIngressPath, len(source.Paths))
		for i := 0; i < len(source.Paths); i++ {
			consolePartialIngressHost.Paths[i] = v1alpha2IngressPathToConsolePartialIngressPath(source.Paths[i])
		}
	}
	return consolePartialIngressHost
}
func v1alpha2IngressPathToConsolePartialIngressPath(source IngressPath) v3.PartialIngressPath {
	var consolePartialIngressPath v3.PartialIngressPath
	pString := source.Path
	consolePartialIngressPath.Path = &pString
	if source.PathType != nil {
		v1PathType := v13.PathType(*source.PathType)
		consolePartialIngressPath.PathType = &v1PathType
	}
	return consolePartialIngressPath
}
func v1alpha2KafkaSASLAWSMskIamToIrKafkaSASLAWSMskIam(source KafkaSASLAWSMskIam, context string) ir.KafkaSASLAWSMskIam {
	var irKafkaSASLAWSMskIam ir.KafkaSASLAWSMskIam
	irKafkaSASLAWSMskIam.AccessKey = source.AccessKey
	irKafkaSASLAWSMskIam.SecretKey = autoconv_SecretKeyRef_To_ir_SecretKeyRef(source.SecretKey, context)
	irKafkaSASLAWSMskIam.SessionToken = autoconv_SecretKeyRef_To_ir_SecretKeyRef(source.SessionToken, context)
	irKafkaSASLAWSMskIam.UserAgent = source.UserAgent
	return irKafkaSASLAWSMskIam
}
func v1alpha2KafkaSASLGSSAPIToIrKafkaSASLGSSAPI(source KafkaSASLGSSAPI, context string) ir.KafkaSASLGSSAPI {
	var irKafkaSASLGSSAPI ir.KafkaSASLGSSAPI
	irKafkaSASLGSSAPI.AuthType = source.AuthType
	irKafkaSASLGSSAPI.KeyTabPath = source.KeyTabPath
	irKafkaSASLGSSAPI.KerberosConfigPath = source.KerberosConfigPath
	irKafkaSASLGSSAPI.ServiceName = source.ServiceName
	irKafkaSASLGSSAPI.Username = source.Username
	irKafkaSASLGSSAPI.Password = autoconv_SecretKeyRef_To_ir_SecretKeyRef(source.Password, context)
	irKafkaSASLGSSAPI.Realm = source.Realm
	irKafkaSASLGSSAPI.EnableFast = source.EnableFast
	return irKafkaSASLGSSAPI
}
func v1alpha2KafkaSASLOAuthBearerToIrKafkaSASLOAuthBearer(source KafkaSASLOAuthBearer, context string) ir.KafkaSASLOAuthBearer {
	var irKafkaSASLOAuthBearer ir.KafkaSASLOAuthBearer
	irKafkaSASLOAuthBearer.Token = autoconv_SecretKeyRef_To_ir_SecretKeyRef(source.Token, context)
	return irKafkaSASLOAuthBearer
}
func v1alpha2SecretConfigToPConsolePartialSecretConfig(source SecretConfig) *v3.PartialSecretConfig {
	var consolePartialSecretConfig v3.PartialSecretConfig
	if source.Create != nil {
		xbool := *source.Create
		consolePartialSecretConfig.Create = &xbool
	}
	consolePartialSecretConfig.Kafka = pV1alpha2KafkaSecretsToPConsolePartialKafkaSecrets(source.Kafka)
	consolePartialSecretConfig.Authentication = pV1alpha2AuthenticationSecretsToPConsolePartialAuthenticationSecrets(source.Authentication)
	if source.License != nil {
		xstring := *source.License
		consolePartialSecretConfig.License = &xstring
	}
	consolePartialSecretConfig.Redpanda = pV1alpha2RedpandaSecretsToPConsolePartialRedpandaSecrets(source.Redpanda)
	consolePartialSecretConfig.Serde = pV1alpha2SerdeSecretsToPConsolePartialSerdeSecrets(source.Serde)
	consolePartialSecretConfig.SchemaRegistry = pV1alpha2SchemaRegistrySecretsToPConsolePartialSchemaRegistrySecrets(source.SchemaRegistry)
	return &consolePartialSecretConfig
}
func v1alpha2SecretMountToConsolePartialSecretMount(source SecretMount) v3.PartialSecretMount {
	var consolePartialSecretMount v3.PartialSecretMount
	pString := source.Name
	consolePartialSecretMount.Name = &pString
	pString2 := source.SecretName
	consolePartialSecretMount.SecretName = &pString2
	pString3 := source.Path
	consolePartialSecretMount.Path = &pString3
	if source.SubPath != nil {
		xstring := *source.SubPath
		consolePartialSecretMount.SubPath = &xstring
	}
	if source.DefaultMode != nil {
		xint32 := *source.DefaultMode
		consolePartialSecretMount.DefaultMode = &xint32
	}
	return consolePartialSecretMount
}
